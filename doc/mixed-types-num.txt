-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Alternative Prelude with numeric and logic expressions typed bottom-up
--   
--   This package provides a version of Prelude where unary and binary
--   operations such as <tt>not</tt>, <tt>+</tt>, <tt>==</tt> have their
--   result type derived from the parameter type(s) and thus supports
--   mixed-type arithmetic and comparisons.
--   
--   See module <a>MixedTypesNumPrelude</a> for further documentation.
--   
--   <i>Ghci 8.0.* fails when loading this package</i> due to ghc bug
--   <a>13385</a>. This bug does not affect ghci 7.10.3 and ghci 8.2.1.
@package mixed-types-num
@version 0.2.0.1


-- | Template Haskell utilities
module Utils.TH.DeclForTypes

-- | A toy example of use:
--   
--   <pre>
--   class HasTT t where
--     type TT t
--     getTT :: t -&gt; TT t
--   
--   $(declForTypes
--     [[t| Integer |], [t| Int |], [t| Rational |]]
--     ( t -&gt; [d|
--       instance HasTT $t where
--         type TT $t = ()
--         getTT _ = ()
--     |]))
--   </pre>
declForTypes :: [Q Type] -> (Q Type -> Q [Dec]) -> Q [Dec]


-- | Prelude without operations that clash with MixedTypes
module Numeric.MixedTypes.PreludeHiding

module Control.CollectErrors

-- | A wrapper around values which can accommodate a list of (potential)
--   errors that have (maybe) occurred during the computation of a value. A
--   value may be missing, leaving only the error(s).
--   
--   Such error collection allows one to write expressions with partial
--   functions (ie functions that fail for some inputs) instead of
--   branching after each application of such function. Dealing with the
--   errors can be moved outside the expression. If the error data contain
--   enough information, their list can be used to trace the source of the
--   errors.
data CollectErrors es v
CollectErrors :: Maybe v -> es -> CollectErrors es v
[getMaybeValueCE] :: CollectErrors es v -> Maybe v
[getErrorsCE] :: CollectErrors es v -> es
type SuitableForCE es = (Monoid es, Eq es, Show es, CanTestErrorsCertain es)
class CanTestErrorsCertain es
hasCertainError :: CanTestErrorsCertain es => es -> Bool
hasCertainErrorCE :: (CanTestErrorsCertain es) => (CollectErrors es v) -> Bool
noValueCE :: es -> CollectErrors es v
prependErrorsCE :: (Monoid es) => es -> CollectErrors es v -> CollectErrors es v
filterValuesWithoutErrorCE :: (SuitableForCE es) => [CollectErrors es v] -> [v]

-- | A safe way to get a value out of the CollectErrors wrapper.
getValueIfNoErrorCE :: (SuitableForCE es) => CollectErrors es v -> (v -> t) -> (es -> t) -> t
ce2ConvertResult :: (Typeable t, Show t, SuitableForCE es) => CollectErrors es t -> Either ConvertError t

-- | A mechanism for adding and removing CollectErrors to a type in a
--   manner that depends on the shape of the type, especially whether it
--   already has CollectErrors.
class (Monoid es, EnsureCE es (EnsureCE es a) ~ EnsureCE es a, EnsureCE es (EnsureNoCE es a) ~ EnsureCE es a, EnsureNoCE es (EnsureCE es a) ~ EnsureNoCE es a, EnsureNoCE es (EnsureNoCE es a) ~ EnsureNoCE es a) => CanEnsureCE es a where type EnsureCE es a type EnsureNoCE es a type EnsureCE es a = CollectErrors es a type EnsureNoCE es a = a ensureCE _ = pure deEnsureCE _ (CollectErrors mv es) = case mv of { Just v | es == mempty -> Right v _ -> Left es } ensureNoCE _ a = (Just a, mempty) noValueECE _ = noValueCE prependErrorsECE _ = prependErrorsCE where {
    type family EnsureCE es a;
    type family EnsureNoCE es a;
    type EnsureCE es a = CollectErrors es a;
    type EnsureNoCE es a = a;
}

-- | Translate a value of a type <tt>a</tt> to a value of a type
--   <tt>EnsureCE es a</tt>.
ensureCE :: CanEnsureCE es a => Maybe es -> a -> EnsureCE es a

-- | Translate a value of a type <tt>a</tt> to a value of a type
--   <tt>EnsureCE es a</tt>.
ensureCE :: (CanEnsureCE es a, EnsureCE es a ~ CollectErrors es a) => Maybe es -> a -> EnsureCE es a
deEnsureCE :: CanEnsureCE es a => Maybe es -> EnsureCE es a -> Either es a
deEnsureCE :: (CanEnsureCE es a, EnsureCE es a ~ CollectErrors es a, Eq es) => Maybe es -> EnsureCE es a -> Either es a
ensureNoCE :: CanEnsureCE es a => Maybe es -> a -> (Maybe (EnsureNoCE es a), es)
ensureNoCE :: (CanEnsureCE es a, EnsureNoCE es a ~ a, Eq es, Monoid es) => Maybe es -> a -> (Maybe (EnsureNoCE es a), es)

-- | Make CollectErrors record with no value, only errors.
noValueECE :: CanEnsureCE es a => Maybe a -> es -> EnsureCE es a

-- | Make CollectErrors record with no value, only errors.
noValueECE :: (CanEnsureCE es a, EnsureCE es a ~ CollectErrors es a) => Maybe a -> es -> CollectErrors es a
prependErrorsECE :: CanEnsureCE es a => Maybe a -> es -> EnsureCE es a -> EnsureCE es a
prependErrorsECE :: (CanEnsureCE es a, EnsureCE es a ~ CollectErrors es a) => Maybe a -> es -> EnsureCE es a -> EnsureCE es a

-- | An unsafe way to get a value out of an CollectErrors wrapper.
getValueOrThrowErrorsNCE :: (SuitableForCE es, CanEnsureCE es v, Show v) => Maybe es -> v -> (EnsureNoCE es v)

-- | Add error collection support to an unary function whose result may
--   already have collected errors.
lift1CE :: (SuitableForCE es, CanEnsureCE es a, CanEnsureCE es c) => (a -> c) -> (CollectErrors es a) -> (EnsureCE es c)

-- | Add error collection support to a binary function whose result may
--   already have collected errors.
lift2CE :: (SuitableForCE es, CanEnsureCE es a, CanEnsureCE es b, CanEnsureCE es c) => (a -> b -> c) -> (CollectErrors es a) -> (CollectErrors es b) -> (EnsureCE es c)

-- | Add error collection support to a binary function whose result may
--   already have collected errors. A version where the second operand is
--   not lifted, only the first one.
lift2TCE :: (SuitableForCE es, CanEnsureCE es a, CanEnsureCE es c) => (a -> b -> c) -> (CollectErrors es a) -> b -> (EnsureCE es c)

-- | Add error collection support to a binary function whose result may
--   already have collected errors. A version where the first operand is
--   not lifted, only the second one.
lift2TLCE :: (SuitableForCE es, CanEnsureCE es b, CanEnsureCE es c) => (a -> b -> c) -> a -> (CollectErrors es b) -> (EnsureCE es c)

-- | Ability to lift collected (potential) errors from inside some
--   structure/collection.
--   
--   This is useful mostly for structures that use the default
--   implementation of 'CanEnsureCE es'.
class (SuitableForCE es) => CanExtractCE es f where extractCE sample_es fc = case mapM fst fcNoCE of { Just fec -> pure fec _ -> noValueCE $ foldMap snd fcNoCE } where fcNoCE = fmap (ensureNoCE sample_es) fc
extractCE :: (CanExtractCE es f, CanEnsureCE es c) => Maybe es -> f c -> CollectErrors es (f (EnsureNoCE es c))
extractCE :: (CanExtractCE es f, CanEnsureCE es c, Traversable f) => Maybe es -> f c -> CollectErrors es (f (EnsureNoCE es c))
instance (GHC.Show.Show v, Control.CollectErrors.SuitableForCE es) => GHC.Show.Show (Control.CollectErrors.CollectErrors es v)
instance GHC.Base.Functor (Control.CollectErrors.CollectErrors es)
instance GHC.Base.Monoid es => GHC.Base.Applicative (Control.CollectErrors.CollectErrors es)
instance GHC.Base.Monoid es => GHC.Base.Monad (Control.CollectErrors.CollectErrors es)
instance (Test.QuickCheck.Arbitrary.Arbitrary t, GHC.Base.Monoid es) => Test.QuickCheck.Arbitrary.Arbitrary (Control.CollectErrors.CollectErrors es t)
instance (Control.CollectErrors.SuitableForCE es, Control.CollectErrors.CanEnsureCE es a) => Control.CollectErrors.CanEnsureCE es (Control.CollectErrors.CollectErrors es a)
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es GHC.Types.Int
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es GHC.Integer.Type.Integer
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es GHC.Real.Rational
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es GHC.Types.Double
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es GHC.Types.Bool
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es GHC.Types.Char
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es ()
instance (Control.CollectErrors.SuitableForCE es, Control.CollectErrors.CanEnsureCE es a) => Control.CollectErrors.CanEnsureCE es (GHC.Base.Maybe a)
instance (Control.CollectErrors.SuitableForCE es, Control.CollectErrors.CanEnsureCE es a) => Control.CollectErrors.CanEnsureCE es (b -> a)


-- | A type of numeric errors to be collected.
module Numeric.CollectErrors
data ErrorCertaintyLevel
ErrorCertain :: ErrorCertaintyLevel
ErrorPotential :: ErrorCertaintyLevel
data NumError
DivByZero :: NumError
OutOfRange :: String -> NumError
NumError :: String -> NumError
type NumErrors = [(ErrorCertaintyLevel, NumError)]
sample_NumErrors :: Maybe [(ErrorCertaintyLevel, NumError)]
type CN = CollectErrors NumErrors
hasCertainError :: CanTestErrorsCertain es => es -> Bool
hasCertainErrorCN :: CN v -> Bool
noValueCN :: NumErrors -> CN v

-- | Construct an empty wrapper indicating that given error has certainly
--   occurred.
noValueNumErrorCertainCN :: NumError -> CN v

-- | Construct an empty wrapper indicating that given error may have
--   occurred.
noValueNumErrorPotentialCN :: NumError -> CN v
getMaybeValueCN :: CN v -> Maybe v
getErrorsCN :: CN v -> NumErrors
prependErrorsCN :: NumErrors -> CN v -> CN v
type CanEnsureCN = CanEnsureCE NumErrors
type EnsureCN a = EnsureCE NumErrors a
type EnsureNoCN a = EnsureNoCE NumErrors a

-- | Translate a value of a type <tt>a</tt> to a value of a type
--   <tt>CollectNumErrors a</tt> except when <tt>a</tt> already is a
--   <tt>CollectNumErrors</tt> type, in which case the value is left as is.
ensureCN :: (CanEnsureCN v) => v -> EnsureCN v

-- | Translate a value of a type <tt>EnsureCN es a</tt> to <tt>a</tt>,
--   throwing an exception if there was an error. If <tt>a</tt> is a
--   <tt>CollectNumErrors</tt> type, then this is just an identity.
deEnsureCN :: (CanEnsureCN v) => EnsureCN v -> Either NumErrors v

-- | Translate a value of a type <tt>a</tt> to a value of a type
--   <tt>CollectNumErrors a</tt> except when <tt>a</tt> already is a
--   <tt>CollectNumErrors</tt> type, in which case the value is left as is.
ensureNoCN :: (CanEnsureCN v) => v -> (Maybe (EnsureNoCN v), NumErrors)
noValueECN :: (CanEnsureCN v) => Maybe v -> NumErrors -> EnsureCN v
prependErrorsECN :: (CanEnsureCN v) => Maybe v -> NumErrors -> EnsureCN v -> EnsureCN v

-- | Construct an empty wrapper indicating that given error has certainly
--   occurred.
noValueNumErrorCertainECN :: (CanEnsureCN v) => Maybe v -> NumError -> EnsureCN v

-- | Construct an empty wrapper indicating that given error may have
--   occurred.
noValueNumErrorPotentialECN :: (CanEnsureCN v) => Maybe v -> NumError -> EnsureCN v
type CanExtractCN f = CanExtractCE NumErrors f
extractCN :: (CanEnsureCN c, CanExtractCN f) => f c -> CN (f (EnsureNoCN c))

-- | Wrap a value in the <tt>CollectNumErrors</tt> wrapper.
cn :: (CanEnsureCN v) => v -> EnsureCN v

-- | An unsafe way to get a value out of the CollectNumErrors wrapper.
deCN :: (CanEnsureCN v) => EnsureCN v -> Either NumErrors v

-- | An unsafe way to get a value out of the CollectNumErrors wrapper.
(~!) :: (CanEnsureCN v, Show v) => v -> EnsureNoCN v
instance GHC.Classes.Eq Numeric.CollectErrors.ErrorCertaintyLevel
instance GHC.Classes.Eq Numeric.CollectErrors.NumError
instance GHC.Show.Show Numeric.CollectErrors.NumError
instance GHC.Show.Show Numeric.CollectErrors.ErrorCertaintyLevel
instance Control.CollectErrors.CanTestErrorsCertain Numeric.CollectErrors.NumErrors


-- | This module defines fixed-type integer and rational literals. This is
--   useful when deriving the type of an expression bottom-up. Eg we would
--   not be able to write <tt>1 &lt; x</tt> when the type of <tt>&lt;</tt>
--   does not force the two sides to be of the same type. We would need to
--   write eg <tt>(1::Integer) &lt; x</tt> with Prelude's generic literals.
--   
--   Moreover, convenient conversion functions are provided for the most
--   common numeric types. Thus one can say eg:
--   
--   <ul>
--   <li><pre>take (int 1)</pre></li>
--   <li><tt>integer (length list)</tt>.</li>
--   <li><pre>double 0.5</pre></li>
--   </ul>
--   
--   To avoid integer overflow, no aritmetic operations return <a>Int</a>.
--   Nevertheless, one can usually mix <a>Int</a> with other types in
--   expressions.
--   
--   Any approximate arithmetic, ie arithmetic involving Doubles, returns
--   values of type <a>Double</a>. <a>Double</a> values cannot be easily
--   converted to exact types such as <a>Rational</a> or <a>Integer</a> so
--   that all such conversions are clearly visible as labelled as inexact.
module Numeric.MixedTypes.Literals

-- | Replacement for <a>fromInteger</a> using the RebindableSyntax
--   extension. This version of fromInteger arranges that integer literals
--   are always of type <a>Integer</a>.
fromInteger :: Integer -> Integer

-- | Replacement for <a>fromRational</a> using the RebindableSyntax
--   extension. This version of fromRational arranges that rational
--   literals are always of type <a>Rational</a>.
fromRational :: Rational -> Rational

-- | Restore if-then-else with RebindableSyntax
class HasIfThenElse b t where type IfThenElseType b t type IfThenElseType b t = t where {
    type family IfThenElseType b t;
    type IfThenElseType b t = t;
}
ifThenElse :: HasIfThenElse b t => b -> t -> t -> IfThenElseType b t
type HasIfThenElseSameType b t = (HasIfThenElse b t, IfThenElseType b t ~ t)
type CanBeInteger t = ConvertibleExactly t Integer
integer :: (CanBeInteger t) => t -> Integer
integers :: (CanBeInteger t) => [t] -> [Integer]
type HasIntegers t = ConvertibleExactly Integer t
fromInteger_ :: (HasIntegers t) => Integer -> t
type CanBeInt t = ConvertibleExactly t Int
int :: (CanBeInt t) => t -> Int
ints :: (CanBeInt t) => [t] -> [Int]
type CanBeRational t = ConvertibleExactly t Rational
rational :: (CanBeRational t) => t -> Rational
rationals :: (CanBeRational t) => [t] -> [Rational]
type HasRationals t = ConvertibleExactly Rational t
fromRational_ :: (HasRationals t) => Rational -> t
type CanBeDouble t = Convertible t Double
double :: (CanBeDouble t) => t -> Double
doubles :: (CanBeDouble t) => [t] -> [Double]

-- | Define our own ConvertibleExactly since convertible is too relaxed for
--   us. For example, convertible allows conversion from Rational to
--   Integer, rounding to nearest integer. We prefer to allow only exact
--   conversions.
class ConvertibleExactly t1 t2 where safeConvertExactly = safeConvert
safeConvertExactly :: ConvertibleExactly t1 t2 => t1 -> ConvertResult t2
safeConvertExactly :: (ConvertibleExactly t1 t2, Convertible t1 t2) => t1 -> ConvertResult t2
convertExactly :: (ConvertibleExactly t1 t2) => t1 -> t2
convertExactlyTargetSample :: (ConvertibleExactly t1 t2) => t2 -> t1 -> t2

-- | The result of a safe conversion via <a>safeConvert</a>.
type ConvertResult a = Either ConvertError a

-- | How we indicate that there was an error.
data ConvertError :: *
convError :: (Show a, Typeable * a, Typeable * b) => String -> a -> ConvertResult b
(!!) :: (CanBeInteger t) => [a] -> t -> a

-- | HSpec properties that each implementation of CanBeInteger should
--   satisfy.
specCanBeInteger :: (CanBeInteger t, Show t, Arbitrary t) => T t -> Spec
printArgsIfFails2 :: (Testable prop, Show a, Show b) => String -> (a -> b -> prop) -> (a -> b -> Property)

-- | A runtime representative of type <tt>t</tt>. Used for specialising
--   polymorphic tests to concrete types.
data T t
T :: String -> T t
tInt :: T Int
tInteger :: T Integer
tRational :: T Rational
tDouble :: T Double
tBool :: T Bool
tMaybe :: T t -> T (Maybe t)
tMaybeBool :: T (Maybe Bool)
tMaybeMaybeBool :: T (Maybe (Maybe Bool))
convertFirst :: (ConvertibleExactly a b) => (b -> b -> c) -> (a -> b -> c)
convertSecond :: (ConvertibleExactly b a) => (a -> a -> c) -> (a -> b -> c)
convertFirstUsing :: (a -> b -> b) -> (b -> b -> c) -> (a -> b -> c)
convertSecondUsing :: (a -> b -> a) -> (a -> a -> c) -> (a -> b -> c)
instance (Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool t0, GHC.Base.Monoid es0) => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool (Control.CollectErrors.CollectErrors es0 t0)
instance (Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer t0, GHC.Base.Monoid es0) => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 t0)
instance (Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int t0, GHC.Base.Monoid es0) => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int (Control.CollectErrors.CollectErrors es0 t0)
instance (Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational t0, GHC.Base.Monoid es0) => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 t0)
instance (Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Double t0, GHC.Base.Monoid es0) => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Double (Control.CollectErrors.CollectErrors es0 t0)
instance Numeric.MixedTypes.Literals.HasIfThenElse GHC.Types.Bool t
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Double GHC.Types.Double


module Numeric.MixedTypes.Bool

-- | A type constraint synonym that stipulates that the type behaves very
--   much like Bool, except it does not necessarily satisfy the law of
--   excluded middle, which means that the type can contain a "do-not-know"
--   value.
--   
--   Examples: <tt>Bool</tt>, <tt>Maybe Bool</tt>, <tt>Maybe (Maybe
--   Bool)</tt>, <tt>CollectErrors Bool</tt>
type IsBool t = (HasBools t, CanNegSameType t, CanAndOrSameType t)

-- | HSpec properties that each implementation of IsBool should satisfy.
specIsBool :: (IsBool t, CanTestCertainly t, Show t, Serial IO t) => T t -> Spec
type HasBools t = ConvertibleExactly Bool t

-- | Tests for truth or falsity. Beware, when <tt>isCertainlyTrue</tt>
--   returns <tt>False</tt>, it does not mean that the proposition is
--   false. It usually means that we failed to prove the proposition.
class (HasBools t) => CanTestCertainly t
isCertainlyTrue :: CanTestCertainly t => t -> Bool
isCertainlyFalse :: CanTestCertainly t => t -> Bool

-- | HSpec properties that each implementation of CanTestCertainly should
--   satisfy.
specCanTestCertainly :: (CanTestCertainly t) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanTestCertainlyX t = (CanTestCertainly t, Show t, Serial IO t)
isNotTrue :: (CanTestCertainly t) => t -> Bool
isNotFalse :: (CanTestCertainly t) => t -> Bool

-- | If l is certainly True, then r is also certainly True.
stronglyImplies :: (CanTestCertainly t1, CanTestCertainly t2) => t1 -> t2 -> Bool
stronglyEquivalentTo :: (CanTestCertainly t1, CanTestCertainly t2) => t1 -> t2 -> Bool

-- | If l is certainly True, then r is not certainly False.
weaklyImplies :: (CanTestCertainly t1, CanTestCertainly t2) => t1 -> t2 -> Bool
weaklyEquivalentTo :: (CanTestCertainly t1, CanTestCertainly t2) => t1 -> t2 -> Bool

-- | This is negation is both the numeric negation as well as the Boolean
--   negation. Example of non-standard Boolean negation:
--   
--   <pre>
--   negate (Just True) = Just False
--   
--   </pre>
class CanNeg t where type NegType t type NegType t = t where {
    type family NegType t;
    type NegType t = t;
}
negate :: CanNeg t => t -> NegType t

-- | A synonym of <a>negate</a>.
not :: (CanNeg t) => t -> NegType t
type CanNegSameType t = (CanNeg t, NegType t ~ t)

-- | HSpec properties that each Boolean implementation of CanNeg should
--   satisfy.
specCanNegBool :: (Show t, Show (NegType (NegType t)), Serial IO t, CanTestCertainly t, CanTestCertainly (NegType t), CanTestCertainly (NegType (NegType t)), CanNeg t, CanNeg (NegType t)) => T t -> Spec
type CanAndOr t1 t2 = (CanAndOrAsymmetric t1 t2, CanAndOrAsymmetric t2 t1, AndOrType t1 t2 ~ AndOrType t2 t1)

-- | Binary logical <a>and</a> and <a>or</a> for generalised Booleans. For
--   example:
--   
--   <pre>
--   (Just True) &amp;&amp; False = Just False
--   (Just (Just True)) || False = (Just (Just True))
--   
--   </pre>
class CanAndOrAsymmetric t1 t2 where type AndOrType t1 t2 where {
    type family AndOrType t1 t2;
}
and2 :: CanAndOrAsymmetric t1 t2 => t1 -> t2 -> AndOrType t1 t2
or2 :: CanAndOrAsymmetric t1 t2 => t1 -> t2 -> AndOrType t1 t2

-- | A synonym of <a>and2</a>.
(&&) :: (CanAndOrAsymmetric a b) => a -> b -> AndOrType a b
infixr 3 &&

-- | A synonym of <a>or2</a>.
(||) :: (CanAndOrAsymmetric a b) => a -> b -> AndOrType a b
infixr 2 ||
type CanAndOrWith t1 t2 = (CanAndOr t1 t2, AndOrType t1 t2 ~ t1)
type CanAndOrSameType t = CanAndOrWith t t
and :: (CanAndOrSameType t, CanTestCertainly t) => [t] -> t
or :: (CanAndOrSameType t, CanTestCertainly t) => [t] -> t

-- | HSpec properties that each implementation of CanAndOr should satisfy.
specCanAndOr :: (Show t1, Show t2, Show t3, Show (AndOrType t1 t1), Show (AndOrType t1 t2), Show (AndOrType t2 t1), Show (AndOrType t1 (AndOrType t2 t3)), Show (AndOrType (AndOrType t1 t2) t3), Show (AndOrType (AndOrType t1 t2) (AndOrType t1 t3)), Show (NegType (AndOrType t1 t2)), Show (AndOrType (NegType t1) (NegType t2)), Serial IO t1, Serial IO t2, Serial IO t3, CanTestCertainly t1, CanTestCertainly (AndOrType t1 t1), CanTestCertainly (AndOrType t1 t2), CanTestCertainly (AndOrType t2 t1), CanTestCertainly (AndOrType t1 (AndOrType t2 t3)), CanTestCertainly (AndOrType (AndOrType t1 t2) t3), CanTestCertainly (AndOrType (AndOrType t1 t2) (AndOrType t1 t3)), CanTestCertainly (NegType (AndOrType t1 t2)), CanTestCertainly (AndOrType (NegType t1) (NegType t2)), CanNeg t1, CanNeg t2, CanNeg (AndOrType t1 t2), CanAndOrAsymmetric t1 t1, CanAndOrAsymmetric t1 t2, CanAndOrAsymmetric t1 t3, CanAndOrAsymmetric t1 (AndOrType t2 t3), CanAndOrAsymmetric t2 t1, CanAndOrAsymmetric t2 t3, CanAndOrAsymmetric (AndOrType t1 t2) t3, CanAndOrAsymmetric (AndOrType t1 t2) (AndOrType t1 t3), CanAndOrAsymmetric (NegType t1) (NegType t2)) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of CanAndOr should satisfy.
specCanAndOrNotMixed :: (Show t, Show (AndOrType t t), Show (AndOrType t (AndOrType t t)), Show (AndOrType (AndOrType t t) t), Show (AndOrType (AndOrType t t) (AndOrType t t)), Show (NegType (AndOrType t t)), Show (AndOrType (NegType t) (NegType t)), Serial IO t, CanTestCertainly t, CanTestCertainly (AndOrType t t), CanTestCertainly (AndOrType t (AndOrType t t)), CanTestCertainly (AndOrType (AndOrType t t) t), CanTestCertainly (AndOrType (AndOrType t t) (AndOrType t t)), CanTestCertainly (NegType (AndOrType t t)), CanTestCertainly (AndOrType (NegType t) (NegType t)), CanNeg t, CanNeg (AndOrType t t), CanAndOrAsymmetric t t, CanAndOrAsymmetric t (AndOrType t t), CanAndOrAsymmetric (AndOrType t t) t, CanAndOrAsymmetric (AndOrType t t) (AndOrType t t), CanAndOrAsymmetric (NegType t) (NegType t)) => T t -> Spec
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool GHC.Types.Bool
instance Numeric.MixedTypes.Bool.CanTestCertainly GHC.Types.Bool
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool t => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool (GHC.Base.Maybe t)
instance Numeric.MixedTypes.Bool.CanTestCertainly t => Numeric.MixedTypes.Bool.CanTestCertainly (GHC.Base.Maybe t)
instance (Numeric.MixedTypes.Bool.CanTestCertainly t, Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Bool.CanTestCertainly (Control.CollectErrors.CollectErrors es t)
instance Numeric.MixedTypes.Bool.CanNeg GHC.Types.Bool
instance Numeric.MixedTypes.Bool.CanNeg t => Numeric.MixedTypes.Bool.CanNeg (GHC.Base.Maybe t)
instance (Numeric.MixedTypes.Bool.CanNeg t, Control.CollectErrors.SuitableForCE es, Control.CollectErrors.CanEnsureCE es t, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Bool.NegType t)) => Numeric.MixedTypes.Bool.CanNeg (Control.CollectErrors.CollectErrors es t)
instance Numeric.MixedTypes.Bool.CanAndOrAsymmetric GHC.Types.Bool GHC.Types.Bool
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric t1 t2, Numeric.MixedTypes.Bool.CanTestCertainly t1, Numeric.MixedTypes.Bool.CanTestCertainly t2, Numeric.MixedTypes.Bool.CanTestCertainly (Numeric.MixedTypes.Bool.AndOrType t1 t2)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric (GHC.Base.Maybe t1) (GHC.Base.Maybe t2)
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric GHC.Types.Bool t2, Numeric.MixedTypes.Bool.CanTestCertainly t2, Numeric.MixedTypes.Bool.CanTestCertainly (Numeric.MixedTypes.Bool.AndOrType GHC.Types.Bool t2)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric GHC.Types.Bool (GHC.Base.Maybe t2)
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric t1 GHC.Types.Bool, Numeric.MixedTypes.Bool.CanTestCertainly t1, Numeric.MixedTypes.Bool.CanTestCertainly (Numeric.MixedTypes.Bool.AndOrType t1 GHC.Types.Bool)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric (GHC.Base.Maybe t1) GHC.Types.Bool
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric t1 t2, Control.CollectErrors.SuitableForCE es, Control.CollectErrors.CanEnsureCE es t1, Control.CollectErrors.CanEnsureCE es t2, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Bool.AndOrType t1 t2)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric (Control.CollectErrors.CollectErrors es t1) (Control.CollectErrors.CollectErrors es t2)
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric t1 GHC.Types.Bool, Control.CollectErrors.SuitableForCE es, Control.CollectErrors.CanEnsureCE es t1, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Bool.AndOrType t1 GHC.Types.Bool)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric (Control.CollectErrors.CollectErrors es t1) GHC.Types.Bool
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric GHC.Types.Bool t2, Control.CollectErrors.SuitableForCE es, Control.CollectErrors.CanEnsureCE es t2, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Bool.AndOrType GHC.Types.Bool t2)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric GHC.Types.Bool (Control.CollectErrors.CollectErrors es t2)


module Numeric.MixedTypes.Eq
type HasEq t1 t2 = (HasEqAsymmetric t1 t2, HasEqAsymmetric t2 t1, EqCompareType t1 t2 ~ EqCompareType t2 t1)
class (IsBool (EqCompareType a b)) => HasEqAsymmetric a b where type EqCompareType a b type EqCompareType a b = Bool equalTo = (==) notEqualTo a b = not $ equalTo a b where {
    type family EqCompareType a b;
    type EqCompareType a b = Bool;
}
equalTo :: HasEqAsymmetric a b => a -> b -> (EqCompareType a b)
equalTo :: (HasEqAsymmetric a b, EqCompareType a b ~ Bool, a ~ b, Eq a) => a -> b -> Bool
notEqualTo :: HasEqAsymmetric a b => a -> b -> (EqCompareType a b)
notEqualTo :: (HasEqAsymmetric a b, CanNegSameType (EqCompareType a b)) => a -> b -> (EqCompareType a b)
(==) :: (HasEqAsymmetric a b) => a -> b -> EqCompareType a b
infix 4 ==
(/=) :: (HasEqAsymmetric a b) => a -> b -> EqCompareType a b
infix 4 /=
type HasEqCertainly t1 t2 = (HasEq t1 t2, CanTestCertainly (EqCompareType t1 t2))
type HasEqCertainlyAsymmetric t1 t2 = (HasEqAsymmetric t1 t2, CanTestCertainly (EqCompareType t1 t2))
type HasEqCertainlyCE es t1 t2 = (HasEqCertainly t1 t2, HasEqCertainly (EnsureCE es t1) (EnsureCE es t2))
type HasEqCertainlyCN t1 t2 = HasEqCertainlyCE NumErrors t1 t2
notCertainlyDifferentFrom :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
certainlyEqualTo :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
certainlyNotEqualTo :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
(?==?) :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?==?
(!==!) :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !==!
(!/=!) :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !/=!

-- | HSpec properties that each implementation of HasEq should satisfy.
specHasEq :: (Show t1, Show t2, Show t3, Arbitrary t1, Arbitrary t2, Arbitrary t3, CanTestCertainly (EqCompareType t1 t1), CanTestCertainly (EqCompareType t1 t2), CanTestCertainly (EqCompareType t2 t1), CanTestCertainly (EqCompareType t2 t3), CanTestCertainly (AndOrType (EqCompareType t1 t2) (EqCompareType t2 t3)), CanAndOrAsymmetric (EqCompareType t1 t2) (EqCompareType t2 t3), HasEqAsymmetric t1 t1, HasEqAsymmetric t1 t2, HasEqAsymmetric t2 t1, HasEqAsymmetric t2 t3) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of HasEq should satisfy.
specHasEqNotMixed :: (Show t, Arbitrary t, CanTestCertainly (EqCompareType t t), CanTestCertainly (AndOrType (EqCompareType t t) (EqCompareType t t)), HasEqAsymmetric t t) => T t -> Spec

-- | HSpec property of there-and-back conversion.
specConversion :: (Arbitrary t1, Show t1, HasEqCertainly t1 t1) => T t1 -> T t2 -> (t1 -> t2) -> (t2 -> t1) -> Spec
class CanTestNaN t where isNaN = isNaN
isNaN :: CanTestNaN t => t -> Bool
isNaN :: (CanTestNaN t, RealFloat t) => t -> Bool
class CanTestFinite t where isInfinite = isInfinite isFinite x = (not $ isNaN x) && (not $ isInfinite x)
isInfinite :: CanTestFinite t => t -> Bool
isInfinite :: (CanTestFinite t, RealFloat t) => t -> Bool
isFinite :: CanTestFinite t => t -> Bool
isFinite :: (CanTestFinite t, RealFloat t) => t -> Bool
class CanTestInteger t where certainlyInteger s = case certainlyIntegerGetIt s of { Just _ -> True _ -> False }
certainlyNotInteger :: CanTestInteger t => t -> Bool
certainlyInteger :: CanTestInteger t => t -> Bool
certainlyIntegerGetIt :: CanTestInteger t => t -> Maybe Integer
class CanTestZero t where isCertainlyZero a = isCertainlyTrue (a == 0) isCertainlyNonZero a = isCertainlyTrue (a /= 0)
isCertainlyZero :: CanTestZero t => t -> Bool
isCertainlyNonZero :: CanTestZero t => t -> Bool
isCertainlyZero :: (CanTestZero t, HasEqCertainly t Integer) => t -> Bool
isCertainlyNonZero :: (CanTestZero t, HasEqCertainly t Integer) => t -> Bool

-- | HSpec properties that each implementation of CanTestZero should
--   satisfy.
specCanTestZero :: (CanTestZero t, ConvertibleExactly Integer t) => T t -> Spec
class CanPickNonZero t where pickNonZero list = aux list where aux ((a, b) : rest) | isCertainlyNonZero a = Just (a, b) | otherwise = aux rest aux [] = Nothing

-- | Given a list <tt>[(a1,b1),(a2,b2),...]</tt> and assuming that at least
--   one of <tt>a1,a2,...</tt> is non-zero, pick one of them and return the
--   corresponding pair <tt>(ai,bi)</tt>.
--   
--   If none of <tt>a1,a2,...</tt> is zero, either throws an exception or
--   loops forever.
--   
--   The default implementation is based on a <a>CanTestZero</a> instance
--   and is not parallel.
pickNonZero :: CanPickNonZero t => [(t, s)] -> Maybe (t, s)

-- | Given a list <tt>[(a1,b1),(a2,b2),...]</tt> and assuming that at least
--   one of <tt>a1,a2,...</tt> is non-zero, pick one of them and return the
--   corresponding pair <tt>(ai,bi)</tt>.
--   
--   If none of <tt>a1,a2,...</tt> is zero, either throws an exception or
--   loops forever.
--   
--   The default implementation is based on a <a>CanTestZero</a> instance
--   and is not parallel.
pickNonZero :: (CanPickNonZero t, CanTestZero t, Show t) => [(t, s)] -> Maybe (t, s)

-- | HSpec properties that each implementation of CanPickNonZero should
--   satisfy.
specCanPickNonZero :: (CanPickNonZero t, CanTestZero t, ConvertibleExactly Integer t, Show t, Arbitrary t) => T t -> Spec
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Bool b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Types.Bool b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Types.Bool b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Bool (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Types.Bool, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Types.Bool), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Types.Bool)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Bool
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric (GHC.Base.Maybe GHC.Types.Bool) b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType (GHC.Base.Maybe GHC.Types.Bool) b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType (GHC.Base.Maybe GHC.Types.Bool) b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric (GHC.Base.Maybe GHC.Types.Bool) (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a0 (GHC.Base.Maybe GHC.Types.Bool), Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 (GHC.Base.Maybe GHC.Types.Bool)), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 (GHC.Base.Maybe GHC.Types.Bool))), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es0 a0) (GHC.Base.Maybe GHC.Types.Bool)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Integer.Type.Integer b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Integer.Type.Integer b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Integer.Type.Integer, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Integer.Type.Integer), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Integer.Type.Integer)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Types.Int b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Types.Int b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Types.Int, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Types.Int), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Types.Int)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Int
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Real.Rational b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Real.Rational b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Real.Rational, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Real.Rational), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Real.Rational)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Real.Rational
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Types.Double b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType GHC.Types.Double b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Types.Double, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Types.Double), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Eq.EqCompareType a0 GHC.Types.Double)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Double
instance Numeric.MixedTypes.Eq.CanTestNaN GHC.Types.Double
instance Numeric.MixedTypes.Eq.CanTestFinite GHC.Types.Double
instance Numeric.MixedTypes.Eq.CanTestNaN GHC.Real.Rational
instance Numeric.MixedTypes.Eq.CanTestFinite GHC.Real.Rational
instance (Numeric.MixedTypes.Eq.CanTestNaN t, Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.CanTestNaN (Control.CollectErrors.CollectErrors es t)
instance (Numeric.MixedTypes.Eq.CanTestFinite t, Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.CanTestFinite (Control.CollectErrors.CollectErrors es t)
instance Numeric.MixedTypes.Eq.CanTestInteger GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.CanTestInteger GHC.Types.Int
instance Numeric.MixedTypes.Eq.CanTestInteger GHC.Real.Rational
instance Numeric.MixedTypes.Eq.CanTestInteger GHC.Types.Double
instance (Numeric.MixedTypes.Eq.CanTestInteger t, Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.CanTestInteger (Control.CollectErrors.CollectErrors es t)
instance Numeric.MixedTypes.Eq.CanTestZero GHC.Types.Int
instance Numeric.MixedTypes.Eq.CanTestZero GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.CanTestZero GHC.Real.Rational
instance Numeric.MixedTypes.Eq.CanTestZero GHC.Types.Double
instance (Numeric.MixedTypes.Eq.CanTestZero t, Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.CanTestZero (Control.CollectErrors.CollectErrors es t)
instance Numeric.MixedTypes.Eq.CanPickNonZero GHC.Types.Int
instance Numeric.MixedTypes.Eq.CanPickNonZero GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.CanPickNonZero GHC.Real.Rational
instance (Numeric.MixedTypes.Eq.CanPickNonZero a, Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.CanPickNonZero (Control.CollectErrors.CollectErrors es a)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric () ()
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Bool GHC.Types.Bool
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Char GHC.Types.Char
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double GHC.Types.Int
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a1 b1, Numeric.MixedTypes.Eq.HasEqAsymmetric a2 b2, Numeric.MixedTypes.Bool.CanAndOrAsymmetric (Numeric.MixedTypes.Eq.EqCompareType a1 b1) (Numeric.MixedTypes.Eq.EqCompareType a2 b2), Numeric.MixedTypes.Bool.IsBool (Numeric.MixedTypes.Bool.AndOrType (Numeric.MixedTypes.Eq.EqCompareType a1 b1) (Numeric.MixedTypes.Eq.EqCompareType a2 b2))) => Numeric.MixedTypes.Eq.HasEqAsymmetric (a1, a2) (b1, b2)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric ((a1, a2), a3) ((b1, b2), b3) => Numeric.MixedTypes.Eq.HasEqAsymmetric (a1, a2, a3) (b1, b2, b3)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric ((a1, a2, a3), a4) ((b1, b2, b3), b4) => Numeric.MixedTypes.Eq.HasEqAsymmetric (a1, a2, a3, a4) (b1, b2, b3, b4)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric ((a1, a2, a3, a4), a5) ((b1, b2, b3, b4), b5) => Numeric.MixedTypes.Eq.HasEqAsymmetric (a1, a2, a3, a4, a5) (b1, b2, b3, b4, b5)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a b => Numeric.MixedTypes.Eq.HasEqAsymmetric [a] [b]
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a b => Numeric.MixedTypes.Eq.HasEqAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Eq.EqCompareType a b), Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es b, Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Eq.EqCompareType a b)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)


module Numeric.MixedTypes.Ord
type HasOrder t1 t2 = (HasOrderAsymmetric t1 t2, HasOrderAsymmetric t2 t1, OrderCompareType t1 t2 ~ OrderCompareType t2 t1)
class (IsBool (OrderCompareType a b)) => HasOrderAsymmetric a b where type OrderCompareType a b type OrderCompareType a b = Bool lessThan = (<) greaterThan a b = lessThan b a leq = (<=) geq a b = leq b a where {
    type family OrderCompareType a b;
    type OrderCompareType a b = Bool;
}
lessThan :: HasOrderAsymmetric a b => a -> b -> (OrderCompareType a b)
lessThan :: (HasOrderAsymmetric a b, OrderCompareType a b ~ Bool, a ~ b, Ord a) => a -> b -> Bool
greaterThan :: HasOrderAsymmetric a b => a -> b -> (OrderCompareType a b)
greaterThan :: (HasOrderAsymmetric a b, HasOrder b a, OrderCompareType b a ~ OrderCompareType a b) => a -> b -> (OrderCompareType a b)
leq :: HasOrderAsymmetric a b => a -> b -> (OrderCompareType a b)
leq :: (HasOrderAsymmetric a b, OrderCompareType a b ~ Bool, a ~ b, Ord a) => a -> b -> Bool
geq :: HasOrderAsymmetric a b => a -> b -> (OrderCompareType a b)
geq :: (HasOrderAsymmetric a b, HasOrder b a, OrderCompareType b a ~ OrderCompareType a b) => a -> b -> (OrderCompareType a b)
(>) :: (HasOrderAsymmetric a b) => a -> b -> OrderCompareType a b
infix 4 >
(<) :: (HasOrderAsymmetric a b) => a -> b -> OrderCompareType a b
infix 4 <
(<=) :: (HasOrderAsymmetric a b) => a -> b -> OrderCompareType a b
infix 4 <=
(>=) :: (HasOrderAsymmetric a b) => a -> b -> OrderCompareType a b
infix 4 >=
type HasOrderCertainlyAsymmetric t1 t2 = (HasOrderAsymmetric t1 t2, CanTestCertainly (OrderCompareType t1 t2))
type HasOrderCertainly t1 t2 = (HasOrder t1 t2, CanTestCertainly (OrderCompareType t1 t2))
type HasOrderCertainlyCE es t1 t2 = (HasOrderCertainly t1 t2, HasOrderCertainly (EnsureCE es t1) (EnsureCE es t2))
type HasOrderCertainlyCN t1 t2 = HasOrderCertainlyCE NumErrors t1 t2
(?<=?) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?<=?
(?<?) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?<?
(?>=?) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?>=?
(?>?) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?>?
(!<=!) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !<=!
(!<!) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !<!
(!>=!) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !>=!
(!>!) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !>!

-- | HSpec properties that each implementation of <a>HasOrder</a> should
--   satisfy.
specHasOrder :: (Show t1, Show t2, Show t3, Arbitrary t1, Arbitrary t2, Arbitrary t3, CanTestCertainly (OrderCompareType t1 t1), CanTestCertainly (OrderCompareType t1 t2), CanTestCertainly (OrderCompareType t2 t1), CanTestCertainly (OrderCompareType t2 t3), CanTestCertainly (AndOrType (OrderCompareType t1 t2) (OrderCompareType t2 t3)), CanAndOrAsymmetric (OrderCompareType t1 t2) (OrderCompareType t2 t3), HasOrderAsymmetric t1 t1, HasOrderAsymmetric t1 t2, HasOrderAsymmetric t2 t1, HasOrderAsymmetric t2 t3) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of <a>HasOrder</a> should
--   satisfy.
specHasOrderNotMixed :: (Show t, Arbitrary t, CanTestCertainly (OrderCompareType t t), CanTestCertainly (AndOrType (OrderCompareType t t) (OrderCompareType t t)), HasOrderAsymmetric t t) => T t -> Spec
class CanTestPosNeg t where isCertainlyPositive a = isCertainlyTrue $ a > 0 isCertainlyNonNegative a = isCertainlyTrue $ a >= 0 isCertainlyNegative a = isCertainlyTrue $ a < 0 isCertainlyNonPositive a = isCertainlyTrue $ a <= 0
isCertainlyPositive :: CanTestPosNeg t => t -> Bool
isCertainlyNonNegative :: CanTestPosNeg t => t -> Bool
isCertainlyNegative :: CanTestPosNeg t => t -> Bool
isCertainlyNonPositive :: CanTestPosNeg t => t -> Bool
isCertainlyPositive :: (CanTestPosNeg t, HasOrderCertainly t Integer) => t -> Bool
isCertainlyNonNegative :: (CanTestPosNeg t, HasOrderCertainly t Integer) => t -> Bool
isCertainlyNegative :: (CanTestPosNeg t, HasOrderCertainly t Integer) => t -> Bool
isCertainlyNonPositive :: (CanTestPosNeg t, HasOrderCertainly t Integer) => t -> Bool
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType GHC.Integer.Type.Integer b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType GHC.Integer.Type.Integer b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric a0 GHC.Integer.Type.Integer, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType a0 GHC.Integer.Type.Integer), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType a0 GHC.Integer.Type.Integer)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ord.HasOrderAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType GHC.Types.Int b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType GHC.Types.Int b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric a0 GHC.Types.Int, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType a0 GHC.Types.Int), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType a0 GHC.Types.Int)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ord.HasOrderAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Int
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType GHC.Real.Rational b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType GHC.Real.Rational b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric a0 GHC.Real.Rational, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType a0 GHC.Real.Rational), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType a0 GHC.Real.Rational)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ord.HasOrderAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Double b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType GHC.Types.Double b0), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType GHC.Types.Double b0)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Double (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric a0 GHC.Types.Double, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType a0 GHC.Types.Double), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es0 (Numeric.MixedTypes.Ord.OrderCompareType a0 GHC.Types.Double)), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ord.HasOrderAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Double
instance Numeric.MixedTypes.Ord.CanTestPosNeg GHC.Types.Int
instance Numeric.MixedTypes.Ord.CanTestPosNeg GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.CanTestPosNeg GHC.Real.Rational
instance Numeric.MixedTypes.Ord.CanTestPosNeg GHC.Types.Double
instance (Numeric.MixedTypes.Ord.CanTestPosNeg t, Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ord.CanTestPosNeg (Control.CollectErrors.CollectErrors es t)
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric () ()
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Double GHC.Types.Int
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric a b, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType a b), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType a b)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ord.HasOrderAsymmetric (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)


module Numeric.MixedTypes.MinMaxAbs
type CanMinMax t1 t2 = (CanMinMaxAsymmetric t1 t2, CanMinMaxAsymmetric t2 t1, MinMaxType t1 t2 ~ MinMaxType t2 t1)

-- | A replacement for Prelude's <a>min</a> and <a>max</a>. If <tt>t1 =
--   t2</tt> and <tt>Ord t1</tt>, then one can use the default
--   implementation to mirror Prelude's <tt>min</tt> and <tt>max</tt>.
class CanMinMaxAsymmetric t1 t2 where type MinMaxType t1 t2 type MinMaxType t1 t2 = t1 min = min max = max where {
    type family MinMaxType t1 t2;
    type MinMaxType t1 t2 = t1;
}
min :: CanMinMaxAsymmetric t1 t2 => t1 -> t2 -> MinMaxType t1 t2
max :: CanMinMaxAsymmetric t1 t2 => t1 -> t2 -> MinMaxType t1 t2
min :: (CanMinMaxAsymmetric t1 t2, MinMaxType t1 t2 ~ t1, t1 ~ t2, Ord t1) => t1 -> t1 -> t1
max :: (CanMinMaxAsymmetric t1 t2, MinMaxType t1 t2 ~ t1, t1 ~ t2, Ord t1) => t1 -> t1 -> t1
type CanMinMaxThis t1 t2 = (CanMinMax t1 t2, MinMaxType t1 t2 ~ t1)
type CanMinMaxSameType t = CanMinMaxThis t t
minimum :: (CanMinMaxSameType t) => [t] -> t
maximum :: (CanMinMaxSameType t) => [t] -> t

-- | HSpec properties that each implementation of CanMinMax should satisfy.
specCanMinMax :: (Show t1, Show t2, Show t3, Show (MinMaxType t1 t2), Show (MinMaxType t1 t1), Show (MinMaxType t2 t1), Show (MinMaxType t1 (MinMaxType t2 t3)), Show (MinMaxType (MinMaxType t1 t2) t3), Arbitrary t1, Arbitrary t2, Arbitrary t3, CanTestCertainly (EqCompareType t1 t1), CanTestCertainly (EqCompareType t2 t2), CanTestCertainly (OrderCompareType (MinMaxType t1 t2) t2), CanTestCertainly (OrderCompareType (MinMaxType t1 t2) t1), CanTestCertainly (EqCompareType (MinMaxType t1 t1) t1), CanTestCertainly (EqCompareType (MinMaxType t1 t2) (MinMaxType t2 t1)), CanTestCertainly (EqCompareType t3 t3), CanTestCertainly (EqCompareType (MinMaxType t1 (MinMaxType t2 t3)) (MinMaxType (MinMaxType t1 t2) t3)), HasEqAsymmetric t1 t1, HasEqAsymmetric t2 t2, HasEqAsymmetric t3 t3, HasEqAsymmetric (MinMaxType t1 t2) (MinMaxType t2 t1), HasEqAsymmetric (MinMaxType t1 t1) t1, HasEqAsymmetric (MinMaxType t1 (MinMaxType t2 t3)) (MinMaxType (MinMaxType t1 t2) t3), HasOrderAsymmetric (MinMaxType t1 t2) t1, HasOrderAsymmetric (MinMaxType t1 t2) t2, CanMinMaxAsymmetric t1 t1, CanMinMaxAsymmetric t1 t2, CanMinMaxAsymmetric t1 (MinMaxType t2 t3), CanMinMaxAsymmetric t2 t1, CanMinMaxAsymmetric t2 t3, CanMinMaxAsymmetric (MinMaxType t1 t2) t3) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of CanMinMax should satisfy.
specCanMinMaxNotMixed :: (Show t, Show (MinMaxType t t), Show (MinMaxType t (MinMaxType t t)), Show (MinMaxType (MinMaxType t t) t), Arbitrary t, CanTestCertainly (EqCompareType t t), CanTestCertainly (OrderCompareType (MinMaxType t t) t), CanTestCertainly (EqCompareType (MinMaxType t t) t), CanTestCertainly (EqCompareType (MinMaxType t t) (MinMaxType t t)), CanTestCertainly (EqCompareType (MinMaxType t (MinMaxType t t)) (MinMaxType (MinMaxType t t) t)), HasEqAsymmetric t t, HasEqAsymmetric (MinMaxType t t) t, HasEqAsymmetric (MinMaxType t t) (MinMaxType t t), HasEqAsymmetric (MinMaxType t (MinMaxType t t)) (MinMaxType (MinMaxType t t) t), HasOrderAsymmetric (MinMaxType t t) t, CanMinMaxAsymmetric t t, CanMinMaxAsymmetric t (MinMaxType t t), CanMinMaxAsymmetric (MinMaxType t t) t) => T t -> Spec

-- | A replacement for Prelude's <a>abs</a>. If <tt>Num t</tt>, then one
--   can use the default implementation to mirror Prelude's <tt>abs</tt>.
class CanAbs t where type AbsType t type AbsType t = t abs = abs where {
    type family AbsType t;
    type AbsType t = t;
}
abs :: CanAbs t => t -> AbsType t
abs :: (CanAbs t, AbsType t ~ t, Num t) => t -> t
type CanAbsSameType t = (CanAbs t, AbsType t ~ t)

-- | HSpec properties that each numeric implementation of CanNeg should
--   satisfy.
specCanNegNum :: (CanNegX t, CanNegX (NegType t), HasEqCertainly t (NegType (NegType t)), ConvertibleExactly Integer t, HasEqCertainly t t, HasEqCertainly t (NegType t), CanTestPosNeg t, CanTestPosNeg (NegType t)) => T t -> Spec

-- | HSpec properties that each implementation of CanAbs should satisfy.
specCanAbs :: (CanAbsX t, CanAbsX (AbsType t)) => T t -> Spec
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.MinMaxAbs.MinMaxType GHC.Integer.Type.Integer b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a0 GHC.Integer.Type.Integer, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.MinMaxAbs.MinMaxType a0 GHC.Integer.Type.Integer), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.MinMaxAbs.MinMaxType GHC.Types.Int b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a0 GHC.Types.Int, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.MinMaxAbs.MinMaxType a0 GHC.Types.Int), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Int
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.MinMaxAbs.MinMaxType GHC.Real.Rational b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a0 GHC.Real.Rational, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.MinMaxAbs.MinMaxType a0 GHC.Real.Rational), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Real.Rational
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Double b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.MinMaxAbs.MinMaxType GHC.Types.Double b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Double (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a0 GHC.Types.Double, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.MinMaxAbs.MinMaxType a0 GHC.Types.Double), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Double
instance Numeric.MixedTypes.Bool.CanNeg GHC.Types.Int
instance Numeric.MixedTypes.Bool.CanNeg GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Bool.CanNeg GHC.Real.Rational
instance Numeric.MixedTypes.Bool.CanNeg GHC.Types.Double
instance Numeric.MixedTypes.MinMaxAbs.CanAbs GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanAbs GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanAbs GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanAbs GHC.Types.Double
instance (Numeric.MixedTypes.MinMaxAbs.CanAbs a, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.MinMaxAbs.AbsType a), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.MinMaxAbs.CanAbs (Control.CollectErrors.CollectErrors es a)
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a b => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric [a] [b]
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a b => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a b, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.MinMaxAbs.MinMaxType a b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)


module Numeric.MixedTypes.AddSub
type CanAdd t1 t2 = (CanAddAsymmetric t1 t2, CanAddAsymmetric t2 t1, AddType t1 t2 ~ AddType t2 t1)

-- | A replacement for Prelude's <a>+</a>. If <tt>t1 = t2</tt> and <tt>Num
--   t1</tt>, then one can use the default implementation to mirror
--   Prelude's <tt>+</tt>.
class CanAddAsymmetric t1 t2 where type AddType t1 t2 type AddType t1 t2 = t1 add = (+) where {
    type family AddType t1 t2;
    type AddType t1 t2 = t1;
}
add :: CanAddAsymmetric t1 t2 => t1 -> t2 -> AddType t1 t2
add :: (CanAddAsymmetric t1 t2, AddType t1 t2 ~ t1, t1 ~ t2, Num t1) => t1 -> t1 -> t1
type CanAddThis t1 t2 = (CanAdd t1 t2, AddType t1 t2 ~ t1)
type CanAddSameType t = CanAddThis t t
(+) :: (CanAddAsymmetric t1 t2) => t1 -> t2 -> AddType t1 t2
infixl 6 +
sum :: (CanAddSameType t, ConvertibleExactly Integer t) => [t] -> t

-- | HSpec properties that each implementation of CanAdd should satisfy.
specCanAdd :: (Show t1, Show t2, Show t3, Show (AddType t1 t1), Show (AddType t1 t2), Show (AddType t2 t1), Show (AddType t1 (AddType t2 t3)), Show (AddType (AddType t1 t2) t3), Arbitrary t1, Arbitrary t2, Arbitrary t3, ConvertibleExactly Integer t1, CanTestCertainly (EqCompareType (AddType t1 t1) t1), CanTestCertainly (EqCompareType (AddType t1 t2) (AddType t2 t1)), CanTestCertainly (EqCompareType (AddType t1 (AddType t2 t3)) (AddType (AddType t1 t2) t3)), CanTestCertainly (OrderCompareType (AddType t1 t2) t2), HasEqAsymmetric (AddType t1 t1) t1, HasEqAsymmetric (AddType t1 t2) (AddType t2 t1), HasEqAsymmetric (AddType t1 (AddType t2 t3)) (AddType (AddType t1 t2) t3), HasOrderAsymmetric (AddType t1 t2) t2, CanTestPosNeg t1, CanAddAsymmetric t1 t1, CanAddAsymmetric t1 t2, CanAddAsymmetric t1 (AddType t2 t3), CanAddAsymmetric t2 t1, CanAddAsymmetric t2 t3, CanAddAsymmetric (AddType t1 t2) t3) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of CanAdd should satisfy.
specCanAddNotMixed :: (Show t, Show (AddType t t), Show (AddType t (AddType t t)), Show (AddType (AddType t t) t), Arbitrary t, ConvertibleExactly Integer t, CanTestCertainly (EqCompareType (AddType t t) t), CanTestCertainly (EqCompareType (AddType t t) (AddType t t)), CanTestCertainly (EqCompareType (AddType t (AddType t t)) (AddType (AddType t t) t)), CanTestCertainly (OrderCompareType (AddType t t) t), HasEqAsymmetric (AddType t t) t, HasEqAsymmetric (AddType t t) (AddType t t), HasEqAsymmetric (AddType t (AddType t t)) (AddType (AddType t t) t), HasOrderAsymmetric (AddType t t) t, CanTestPosNeg t, CanAddAsymmetric t t, CanAddAsymmetric t (AddType t t), CanAddAsymmetric (AddType t t) t) => T t -> Spec

-- | HSpec properties that each implementation of CanAddSameType should
--   satisfy.
specCanAddSameType :: (ConvertibleExactly Integer t, Show t, HasEqCertainly t t, CanAddSameType t) => T t -> Spec

-- | A replacement for Prelude's binary <a>-</a>.
--   
--   If <tt>CanNeg t2</tt> and <tt>CanAdd t1 (NegType t2)</tt>, then one
--   can use the default implementation via <tt>a-b = a + (-b)</tt>.
class CanSub t1 t2 where type SubType t1 t2 type SubType t1 t2 = AddType t1 (NegType t2) a `sub` b = a + (negate b) where {
    type family SubType t1 t2;
    type SubType t1 t2 = AddType t1 (NegType t2);
}
sub :: CanSub t1 t2 => t1 -> t2 -> SubType t1 t2
sub :: (CanSub t1 t2, SubType t1 t2 ~ AddType t1 (NegType t2), CanNeg t2, CanAdd t1 (NegType t2)) => t1 -> t2 -> SubType t1 t2
type CanSubThis t1 t2 = (CanSub t1 t2, SubType t1 t2 ~ t1)
type CanSubSameType t = CanSubThis t t
(-) :: (CanSub t1 t2) => t1 -> t2 -> SubType t1 t2
infixl 6 -

-- | HSpec properties that each implementation of CanSub should satisfy.
specCanSub :: (Show t1, Show t2, Show (SubType t1 t1), Show (SubType t1 t2), Show (AddType t1 (NegType t2)), Arbitrary t1, Arbitrary t2, ConvertibleExactly Integer t1, CanTestCertainly (EqCompareType (SubType t1 t1) t1), CanTestCertainly (EqCompareType (SubType t1 t2) (AddType t1 (NegType t2))), CanNeg t2, HasEqAsymmetric (SubType t1 t1) t1, HasEqAsymmetric (SubType t1 t2) (AddType t1 (NegType t2)), CanSub t1 t1, CanSub t1 t2, CanAddAsymmetric t1 (NegType t2)) => T t1 -> T t2 -> Spec

-- | HSpec properties that each implementation of CanSub should satisfy.
specCanSubNotMixed :: (Show t, Show (SubType t t), Show (AddType t (NegType t)), Arbitrary t, ConvertibleExactly Integer t, CanTestCertainly (EqCompareType (SubType t t) t), CanTestCertainly (EqCompareType (SubType t t) (AddType t (NegType t))), CanNeg t, HasEqAsymmetric (SubType t t) t, HasEqAsymmetric (SubType t t) (AddType t (NegType t)), CanSub t t, CanAddAsymmetric t (NegType t)) => T t -> Spec
instance (Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.SubType GHC.Integer.Type.Integer b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.AddSub.CanSub a0 GHC.Integer.Type.Integer, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.SubType a0 GHC.Integer.Type.Integer), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanSub (Control.CollectErrors.CollectErrors es0 a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.AddType GHC.Integer.Type.Integer b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Integer.Type.Integer, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.AddType a0 GHC.Integer.Type.Integer), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.SubType GHC.Types.Int b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.AddSub.CanSub a0 GHC.Types.Int, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.SubType a0 GHC.Types.Int), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanSub (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Int
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.AddType GHC.Types.Int b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Types.Int, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.AddType a0 GHC.Types.Int), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Int
instance (Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.SubType GHC.Real.Rational b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.AddSub.CanSub a0 GHC.Real.Rational, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.SubType a0 GHC.Real.Rational), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanSub (Control.CollectErrors.CollectErrors es0 a0) GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.AddType GHC.Real.Rational b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Real.Rational, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.AddType a0 GHC.Real.Rational), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.SubType GHC.Types.Double b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.AddSub.CanSub a0 GHC.Types.Double, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.SubType a0 GHC.Types.Double), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanSub (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Double
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.AddType GHC.Types.Double b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Types.Double, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.AddSub.AddType a0 GHC.Types.Double), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a b => Numeric.MixedTypes.AddSub.CanAddAsymmetric [a] [b]
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a b => Numeric.MixedTypes.AddSub.CanAddAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric a b, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.AddType a b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub a b => Numeric.MixedTypes.AddSub.CanSub [a] [b]
instance Numeric.MixedTypes.AddSub.CanSub a b => Numeric.MixedTypes.AddSub.CanSub (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance (Numeric.MixedTypes.AddSub.CanSub a b, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.SubType a b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanSub (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)


module Numeric.MixedTypes.Round

-- | A replacement for Prelude's <a>RealFrac</a> operations, such as round
--   in which the result type is fixed to Integer.
--   
--   If <tt>RealFrac t</tt> and <tt>CanTestPosNeg t</tt>, then one can use
--   the default implementation to mirror Prelude's <tt>round</tt>, etc.
--   
--   In other cases, it is sufficient to define <a>properFraction</a>.
class CanRound t where properFraction = properFraction truncate = fst . properFraction round x | - 0.5 !<! r && r !<! 0.5 = n | r !<! - 0.5 = n - 1 | r !>! 0.5 = n + 1 | even n = n | r !<! 0.0 = n - 1 | r !>! 0.0 = n + 1 | otherwise = error "round default defn: Bad value" where (n, r) = properFraction x ceiling x | isCertainlyPositive r = n + 1 | otherwise = n where (n, r) = properFraction x floor x | isCertainlyNegative r = n - 1 | otherwise = n where (n, r) = properFraction x
properFraction :: CanRound t => t -> (Integer, t)
properFraction :: (CanRound t, RealFrac t) => t -> (Integer, t)
truncate :: CanRound t => t -> Integer
round :: CanRound t => t -> Integer
round :: (CanRound t, HasOrderCertainly t Rational) => t -> Integer
ceiling :: CanRound t => t -> Integer
ceiling :: (CanRound t, CanTestPosNeg t) => t -> Integer
floor :: CanRound t => t -> Integer
floor :: (CanRound t, CanTestPosNeg t) => t -> Integer
class HasIntegerBounds t where integerBounds x = (floor x, ceiling x)
integerBounds :: HasIntegerBounds t => t -> (Integer, Integer)
integerBounds :: (HasIntegerBounds t, CanRound t) => t -> (Integer, Integer)

-- | HSpec properties that each implementation of CanRound should satisfy.
specCanRound :: (CanRoundX t, HasIntegers t) => T t -> Spec

-- | HSpec properties that each implementation of CanRound should satisfy.
specHasIntegerBounds :: (HasIntegerBoundsX t) => T t -> Spec
instance Numeric.MixedTypes.Round.CanRound GHC.Real.Rational
instance Numeric.MixedTypes.Round.CanRound GHC.Types.Double
instance Numeric.MixedTypes.Round.HasIntegerBounds GHC.Real.Rational
instance Numeric.MixedTypes.Round.HasIntegerBounds GHC.Types.Double
instance Numeric.MixedTypes.Round.HasIntegerBounds GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Round.HasIntegerBounds GHC.Types.Int


module Numeric.MixedTypes.Ring
type CanAddSubMulBy t s = (CanAddThis t s, CanSubThis t s, CanMulBy t s)
class (RingPre t, CanEnsureCN t, RingPre (EnsureCN t)) => Ring t
class (Ring t, HasEq t t, HasEq (EnsureCN t) t, HasEq t (EnsureCN t), HasEq t Int, HasEq t Integer, HasEq (EnsureCN t) Int, HasEq (EnsureCN t) Integer, HasOrder t t, HasOrder (EnsureCN t) t, HasOrder t (EnsureCN t), HasOrder t Int, HasOrder t Integer, HasOrder (EnsureCN t) Int, HasOrder (EnsureCN t) Integer) => OrderedRing t
class (Ring t, HasEqCertainly t t, HasEqCertainly (EnsureCN t) t, HasEqCertainly t (EnsureCN t), HasEqCertainly t Int, HasEq t Integer, HasEqCertainly (EnsureCN t) Int, HasEq (EnsureCN t) Integer, HasOrderCertainly t t, HasOrderCertainly (EnsureCN t) t, HasOrderCertainly t (EnsureCN t), HasOrderCertainly t Int, HasOrderCertainly t Integer, HasOrderCertainly (EnsureCN t) Int, HasOrderCertainly (EnsureCN t) Integer, CanTestPosNeg t) => OrderedCertainlyRing t
type CanMul t1 t2 = (CanMulAsymmetric t1 t2, CanMulAsymmetric t2 t1, MulType t1 t2 ~ MulType t2 t1)

-- | A replacement for Prelude's <a>*</a>. If <tt>t1 = t2</tt> and <tt>Num
--   t1</tt>, then one can use the default implementation to mirror
--   Prelude's <tt>*</tt>.
class CanMulAsymmetric t1 t2 where type MulType t1 t2 type MulType t1 t2 = t1 mul = (*) where {
    type family MulType t1 t2;
    type MulType t1 t2 = t1;
}
mul :: CanMulAsymmetric t1 t2 => t1 -> t2 -> MulType t1 t2
mul :: (CanMulAsymmetric t1 t2, MulType t1 t2 ~ t1, t1 ~ t2, Num t1) => t1 -> t1 -> t1
type CanMulBy t1 t2 = (CanMul t1 t2, MulType t1 t2 ~ t1)
type CanMulSameType t = CanMulBy t t
(*) :: (CanMulAsymmetric t1 t2) => t1 -> t2 -> MulType t1 t2
infixl 7 *
product :: (CanMulSameType t, ConvertibleExactly Integer t) => [t] -> t

-- | HSpec properties that each implementation of CanMul should satisfy.
specCanMul :: (Show t1, Show t2, Show t3, Show (MulType t1 t2), Show (MulType t2 t1), Show (MulType t1 (MulType t2 t3)), Show (MulType (MulType t1 t2) t3), Show (MulType t1 (AddType t2 t3)), Show (AddType (MulType t1 t2) (MulType t1 t3)), Arbitrary t1, Arbitrary t2, Arbitrary t3, ConvertibleExactly Integer t2, CanTestCertainly (EqCompareType (MulType t1 t2) t1), CanTestCertainly (EqCompareType (MulType t1 t2) (MulType t2 t1)), CanTestCertainly (EqCompareType (MulType t1 (MulType t2 t3)) (MulType (MulType t1 t2) t3)), CanTestCertainly (EqCompareType (MulType t1 (AddType t2 t3)) (AddType (MulType t1 t2) (MulType t1 t3))), HasEqAsymmetric (MulType t1 t2) t1, HasEqAsymmetric (MulType t1 t2) (MulType t2 t1), HasEqAsymmetric (MulType t1 (MulType t2 t3)) (MulType (MulType t1 t2) t3), HasEqAsymmetric (MulType t1 (AddType t2 t3)) (AddType (MulType t1 t2) (MulType t1 t3)), CanAddAsymmetric t2 t3, CanAddAsymmetric (MulType t1 t2) (MulType t1 t3), CanMulAsymmetric t1 t2, CanMulAsymmetric t1 t3, CanMulAsymmetric t1 (MulType t2 t3), CanMulAsymmetric t1 (AddType t2 t3), CanMulAsymmetric t2 t1, CanMulAsymmetric t2 t3, CanMulAsymmetric (MulType t1 t2) t3) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of CanMul should satisfy.
specCanMulNotMixed :: (Show t, Show (MulType t t), Show (MulType t (MulType t t)), Show (MulType (MulType t t) t), Show (MulType t (AddType t t)), Show (AddType (MulType t t) (MulType t t)), Arbitrary t, ConvertibleExactly Integer t, CanTestCertainly (EqCompareType (MulType t t) t), CanTestCertainly (EqCompareType (MulType t t) (MulType t t)), CanTestCertainly (EqCompareType (MulType t (MulType t t)) (MulType (MulType t t) t)), CanTestCertainly (EqCompareType (MulType t (AddType t t)) (AddType (MulType t t) (MulType t t))), HasEqAsymmetric (MulType t t) t, HasEqAsymmetric (MulType t t) (MulType t t), HasEqAsymmetric (MulType t (MulType t t)) (MulType (MulType t t) t), HasEqAsymmetric (MulType t (AddType t t)) (AddType (MulType t t) (MulType t t)), CanAddAsymmetric t t, CanAddAsymmetric (MulType t t) (MulType t t), CanMulAsymmetric t t, CanMulAsymmetric t (MulType t t), CanMulAsymmetric t (AddType t t), CanMulAsymmetric (MulType t t) t) => T t -> Spec

-- | HSpec properties that each implementation of CanMulSameType should
--   satisfy.
specCanMulSameType :: (Show t, ConvertibleExactly Integer t, CanTestCertainly (EqCompareType t t), HasEqAsymmetric t t, CanMulAsymmetric t t, MulType t t ~ t) => T t -> Spec

-- | A replacement for Prelude's binary <a>^</a> and <a>^^</a>. If <tt>Num
--   t1</tt> and <tt>Integral t2</tt>, then one can use the default
--   implementation to mirror Prelude's <tt>^</tt>.
class CanPow b e where type PowTypeNoCN b e type PowType b e type PowTypeNoCN b e = b type PowType b e = EnsureCN (PowTypeNoCN b e) pow = powCN powNoCN where {
    type family PowTypeNoCN b e;
    type family PowType b e;
    type PowTypeNoCN b e = b;
    type PowType b e = EnsureCN (PowTypeNoCN b e);
}
powNoCN :: CanPow b e => b -> e -> PowTypeNoCN b e
pow :: CanPow b e => b -> e -> PowType b e
pow :: (CanPow b e, HasOrderCertainly b Integer, HasOrderCertainly e Integer, HasEqCertainly b Integer, CanTestInteger e, CanEnsureCN (PowTypeNoCN b e)) => b -> e -> EnsureCN (PowTypeNoCN b e)
type CanPowBy t1 t2 = (CanPow t1 t2, PowType t1 t2 ~ t1, PowTypeNoCN t1 t2 ~ t1)
type CanPowCNBy t1 t2 = (CanPow t1 t2, PowType t1 t2 ~ EnsureCN t1, PowTypeNoCN t1 t2 ~ t1, CanEnsureCN t1, CanPow (EnsureCN t1) t2, PowType (EnsureCN t1) t2 ~ EnsureCN t1, PowTypeNoCN (EnsureCN t1) t2 ~ (EnsureCN t1))
(^) :: (CanPow t1 t2) => t1 -> t2 -> PowType t1 t2
infixl 8 ^

-- | Like <a>^</a> but throwing an exception if the power is undefined.
(^!) :: (CanPow t1 t2) => t1 -> t2 -> PowTypeNoCN t1 t2
infixl 8 ^!
powUsingMul :: (CanBeInteger e, CanMulSameType t) => t -> t -> e -> t
integerPowCN :: (HasOrderCertainly b Integer, HasOrderCertainly e Integer, HasEqCertainly b Integer, HasEqCertainly e Integer, CanEnsureCN r) => (b -> e -> r) -> b -> e -> EnsureCN r

-- | HSpec properties that each implementation of CanPow should satisfy.
specCanPow :: (Show t1, Show t2, Show (PowType t1 t2), Show (MulType t1 (PowType t1 t2)), Show (PowType t1 (AddType t2 Integer)), Arbitrary t1, Arbitrary t2, ConvertibleExactly Integer t1, ConvertibleExactly Integer t2, CanTestCertainly (EqCompareType (PowType t1 t2) t1), CanTestCertainly (EqCompareType (MulType t1 (PowType t1 t2)) (PowType t1 (AddType t2 Integer))), HasEqAsymmetric (PowType t1 t2) t1, HasEqAsymmetric (MulType t1 (PowType t1 t2)) (PowType t1 (AddType t2 Integer)), CanTestPosNeg t2, CanAddAsymmetric t2 Integer, CanPow t1 t2, CanPow t1 (AddType t2 Integer), CanMulAsymmetric t1 (PowType t1 t2)) => T t1 -> T t2 -> Spec
instance (Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowType GHC.Integer.Type.Integer b0), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowTypeNoCN GHC.Integer.Type.Integer b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ring.CanPow a0 GHC.Integer.Type.Integer, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowType a0 GHC.Integer.Type.Integer), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowTypeNoCN a0 GHC.Integer.Type.Integer), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanPow (Control.CollectErrors.CollectErrors es0 a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.MulType GHC.Integer.Type.Integer b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Integer.Type.Integer, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.MulType a0 GHC.Integer.Type.Integer), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ring.CanPow GHC.Types.Int b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowType GHC.Types.Int b0), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowTypeNoCN GHC.Types.Int b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanPow GHC.Types.Int (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ring.CanPow a0 GHC.Types.Int, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowType a0 GHC.Types.Int), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowTypeNoCN a0 GHC.Types.Int), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanPow (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Int
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.MulType GHC.Types.Int b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Types.Int, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.MulType a0 GHC.Types.Int), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Int
instance (Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowType GHC.Real.Rational b0), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowTypeNoCN GHC.Real.Rational b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ring.CanPow a0 GHC.Real.Rational, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowType a0 GHC.Real.Rational), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowTypeNoCN a0 GHC.Real.Rational), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanPow (Control.CollectErrors.CollectErrors es0 a0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.MulType GHC.Real.Rational b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Real.Rational, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.MulType a0 GHC.Real.Rational), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanPow GHC.Types.Double b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowType GHC.Types.Double b0), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowTypeNoCN GHC.Types.Double b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanPow GHC.Types.Double (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ring.CanPow a0 GHC.Types.Double, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowType a0 GHC.Types.Double), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.PowTypeNoCN a0 GHC.Types.Double), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanPow (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Double
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.MulType GHC.Types.Double b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Types.Double, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Ring.MulType a0 GHC.Types.Double), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Double
instance Numeric.MixedTypes.Ring.Ring GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.Ring (Numeric.CollectErrors.CN GHC.Integer.Type.Integer)
instance Numeric.MixedTypes.Ring.Ring GHC.Real.Rational
instance Numeric.MixedTypes.Ring.Ring (Numeric.CollectErrors.CN GHC.Real.Rational)
instance Numeric.MixedTypes.Ring.OrderedRing GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.OrderedRing (Numeric.CollectErrors.CN GHC.Integer.Type.Integer)
instance Numeric.MixedTypes.Ring.OrderedRing GHC.Real.Rational
instance Numeric.MixedTypes.Ring.OrderedRing (Numeric.CollectErrors.CN GHC.Real.Rational)
instance Numeric.MixedTypes.Ring.OrderedCertainlyRing GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.OrderedCertainlyRing (Numeric.CollectErrors.CN GHC.Integer.Type.Integer)
instance Numeric.MixedTypes.Ring.OrderedCertainlyRing GHC.Real.Rational
instance Numeric.MixedTypes.Ring.OrderedCertainlyRing (Numeric.CollectErrors.CN GHC.Real.Rational)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a b => Numeric.MixedTypes.Ring.CanMulAsymmetric [a] [b]
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a b => Numeric.MixedTypes.Ring.CanMulAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a b, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.MulType a b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow a b => Numeric.MixedTypes.Ring.CanPow (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance (Numeric.MixedTypes.Ring.CanPow a b, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowTypeNoCN a b), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowType a b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanPow (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)


module Numeric.MixedTypes.Field
type CanAddSubMulDivCNBy t s = (CanAddSubMulBy t s, CanAddSubMulBy (EnsureCN t) s, CanDivCNBy t s)
class (Ring t, CanDivCNSameType t, CanRecipCNSameType t, CanAddSubMulDivCNBy t Rational, CanAddSubMulDivCNBy t Integer, CanAddSubMulDivCNBy t Int) => Field t
class (Field t, OrderedRing t, HasOrder t Rational, HasOrder (EnsureCN t) Rational) => OrderedField t
class (Field t, OrderedCertainlyRing t, HasOrderCertainly t Rational, HasOrderCertainly (EnsureCN t) Rational) => OrderedCertainlyField t

-- | A replacement for Prelude's binary <a>/</a>. If <tt>t1 = t2</tt> and
--   <tt>Fractional t1</tt>, then one can use the default implementation to
--   mirror Prelude's <tt>/</tt>.
class CanDiv t1 t2 where type DivTypeNoCN t1 t2 type DivType t1 t2 type DivType t1 t2 = EnsureCN (DivTypeNoCN t1 t2) divide = divideCN divideNoCN where {
    type family DivTypeNoCN t1 t2;
    type family DivType t1 t2;
    type DivType t1 t2 = EnsureCN (DivTypeNoCN t1 t2);
}
divideNoCN :: CanDiv t1 t2 => t1 -> t2 -> DivTypeNoCN t1 t2
divide :: CanDiv t1 t2 => t1 -> t2 -> DivType t1 t2
divide :: (CanDiv t1 t2, CanTestZero t2, CanEnsureCN (DivTypeNoCN t1 t2)) => t1 -> t2 -> EnsureCN (DivTypeNoCN t1 t2)
type CanDivBy t1 t2 = (CanDiv t1 t2, DivType t1 t2 ~ t1, DivTypeNoCN t1 t2 ~ t1)
type CanDivCNBy t1 t2 = (CanDiv t1 t2, DivType t1 t2 ~ EnsureCN t1, DivTypeNoCN t1 t2 ~ t1, CanEnsureCN t1, CanDiv (EnsureCN t1) t2, DivType (EnsureCN t1) t2 ~ EnsureCN t1, DivTypeNoCN (EnsureCN t1) t2 ~ (EnsureCN t1))
type CanDivSameType t = CanDivBy t t
type CanDivCNSameType t = (CanDivCNBy t t, CanDiv (EnsureCN t) (EnsureCN t), DivType (EnsureCN t) (EnsureCN t) ~ EnsureCN t, DivTypeNoCN (EnsureCN t) (EnsureCN t) ~ (EnsureCN t))
type CanRecip t = CanDiv Integer t
type CanRecipSameType t = (CanDiv Integer t, DivType Integer t ~ t, DivTypeNoCN Integer t ~ t)
type CanRecipCNSameType t = (CanDiv Integer t, DivType Integer t ~ EnsureCN t, DivTypeNoCN Integer t ~ t, CanEnsureCN t, CanDiv Integer (EnsureCN t), DivType Integer (EnsureCN t) ~ EnsureCN t, DivTypeNoCN Integer (EnsureCN t) ~ (EnsureCN t))
(/) :: (CanDiv t1 t2) => t1 -> t2 -> DivType t1 t2
infixl 7 /
(/!) :: (CanDiv t1 t2) => t1 -> t2 -> DivTypeNoCN t1 t2
infixl 7 /!
recip :: (CanRecip t) => t -> DivType Integer t
powUsingMulRecip :: (CanBeInteger e, CanRecipCNSameType t, CanMulSameType t, CanEnsureCN t) => t -> t -> e -> EnsureCN t

-- | HSpec properties that each implementation of CanDiv should satisfy.
specCanDiv :: (Show t1, Show t2, Show (DivType Integer (DivType Integer t1)), Show (DivType t1 t2), Show (DivType t1 t1), Show (MulType t1 (DivType t1 t2)), Arbitrary t1, Arbitrary t2, ConvertibleExactly Integer t1, ConvertibleExactly Integer t2, CanTestCertainly (EqCompareType (DivType Integer (DivType Integer t1)) t1), CanTestCertainly (EqCompareType (DivType t1 t2) t1), CanTestCertainly (EqCompareType (DivType t1 t1) t1), CanTestCertainly (EqCompareType (DivType t1 t2) (MulType t1 (DivType t1 t2))), HasEqAsymmetric (DivType Integer (DivType Integer t1)) t1, HasEqAsymmetric (DivType t1 t2) t1, HasEqAsymmetric (DivType t1 t2) (MulType t1 (DivType t1 t2)), HasEqAsymmetric (DivType t1 t1) t1, CanTestZero t1, CanTestZero t2, CanTestZero (DivType Integer t1), CanMulAsymmetric t1 (DivType t1 t2), CanDiv t1 t1, CanDiv t1 t2, CanDiv Integer t1, CanDiv Integer (DivType Integer t1)) => T t1 -> T t2 -> Spec

-- | HSpec properties that each implementation of CanDiv should satisfy.
specCanDivNotMixed :: (Show t, Show (DivType Integer (DivType Integer t)), Show (DivType t t), Show (MulType t (DivType t t)), Arbitrary t, ConvertibleExactly Integer t, CanTestCertainly (EqCompareType (DivType Integer (DivType Integer t)) t), CanTestCertainly (EqCompareType (DivType t t) t), CanTestCertainly (EqCompareType (DivType t t) (MulType t (DivType t t))), HasEqAsymmetric (DivType Integer (DivType Integer t)) t, HasEqAsymmetric (DivType t t) t, HasEqAsymmetric (DivType t t) (MulType t (DivType t t)), CanTestZero t, CanTestZero (DivType Integer t), CanMulAsymmetric t (DivType t t), CanDiv t t, CanDiv Integer t, CanDiv Integer (DivType Integer t)) => T t -> Spec
instance (Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivType GHC.Integer.Type.Integer b0), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivTypeNoCN GHC.Integer.Type.Integer b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Field.CanDiv a0 GHC.Integer.Type.Integer, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivType a0 GHC.Integer.Type.Integer), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivTypeNoCN a0 GHC.Integer.Type.Integer), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Field.CanDiv (Control.CollectErrors.CollectErrors es0 a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Field.CanDiv GHC.Types.Int b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivType GHC.Types.Int b0), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivTypeNoCN GHC.Types.Int b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Field.CanDiv GHC.Types.Int (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Field.CanDiv a0 GHC.Types.Int, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivType a0 GHC.Types.Int), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivTypeNoCN a0 GHC.Types.Int), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Field.CanDiv (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Int
instance (Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivType GHC.Real.Rational b0), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivTypeNoCN GHC.Real.Rational b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Field.CanDiv a0 GHC.Real.Rational, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivType a0 GHC.Real.Rational), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivTypeNoCN a0 GHC.Real.Rational), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Field.CanDiv (Control.CollectErrors.CollectErrors es0 a0) GHC.Real.Rational
instance (Numeric.MixedTypes.Field.CanDiv GHC.Types.Double b0, Control.CollectErrors.CanEnsureCE es0 b0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivType GHC.Types.Double b0), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivTypeNoCN GHC.Types.Double b0), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Field.CanDiv GHC.Types.Double (Control.CollectErrors.CollectErrors es0 b0)
instance (Numeric.MixedTypes.Field.CanDiv a0 GHC.Types.Double, Control.CollectErrors.CanEnsureCE es0 a0, Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivType a0 GHC.Types.Double), Control.CollectErrors.CanEnsureCE es0 (Numeric.MixedTypes.Field.DivTypeNoCN a0 GHC.Types.Double), Control.CollectErrors.SuitableForCE es0) => Numeric.MixedTypes.Field.CanDiv (Control.CollectErrors.CollectErrors es0 a0) GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv a b => Numeric.MixedTypes.Field.CanDiv [a] [b]
instance Numeric.MixedTypes.Field.CanDiv a b => Numeric.MixedTypes.Field.CanDiv (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance (Numeric.MixedTypes.Field.CanDiv a b, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivType a b), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivTypeNoCN a b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Field.CanDiv (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)
instance Numeric.MixedTypes.Field.Field GHC.Real.Rational
instance Numeric.MixedTypes.Field.Field (Numeric.CollectErrors.CN GHC.Real.Rational)
instance Numeric.MixedTypes.Field.OrderedField GHC.Real.Rational
instance Numeric.MixedTypes.Field.OrderedField (Numeric.CollectErrors.CN GHC.Real.Rational)
instance Numeric.MixedTypes.Field.OrderedCertainlyField GHC.Real.Rational
instance Numeric.MixedTypes.Field.OrderedCertainlyField (Numeric.CollectErrors.CN GHC.Real.Rational)
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double GHC.Types.Double


module Numeric.MixedTypes.Elementary

-- | A replacement for Prelude's <a>sqrt</a>. If <tt>Floating t</tt>, then
--   one can use the default implementation to mirror Prelude's
--   <tt>sqrt</tt>.
class CanSqrt t where type SqrtType t type SqrtType t = t sqrt = sqrt where {
    type family SqrtType t;
    type SqrtType t = t;
}
sqrt :: CanSqrt t => t -> SqrtType t
sqrt :: (CanSqrt t, SqrtType t ~ t, Floating t) => t -> t
type CanSqrtSameType t = (CanSqrt t, SqrtType t ~ t)
type CanSqrtCNSameType t = (CanSqrt t, SqrtType t ~ EnsureCN t)

-- | HSpec properties that each implementation of CanSqrt should satisfy.
specCanSqrtReal :: (Show t, Show (SqrtType t), Show (PowType (SqrtType t) Integer), Arbitrary t, CanTestCertainly (OrderCompareType (SqrtType t) Integer), CanTestCertainly (EqCompareType (PowType (SqrtType t) Integer) t), HasEqAsymmetric (PowType (SqrtType t) Integer) t, HasOrderAsymmetric (SqrtType t) Integer, CanTestPosNeg t, CanPow (SqrtType t) Integer, CanSqrt t) => T t -> Spec

-- | A replacement for Prelude's <a>exp</a>. If <tt>Floating t</tt>, then
--   one can use the default implementation to mirror Prelude's
--   <tt>exp</tt>.
class CanExp t where type ExpType t type ExpType t = t exp = exp where {
    type family ExpType t;
    type ExpType t = t;
}
exp :: CanExp t => t -> ExpType t
exp :: (CanExp t, ExpType t ~ t, Floating t) => t -> t
type CanExpSameType t = (CanExp t, ExpType t ~ t)

-- | HSpec properties that each implementation of CanExp should satisfy.
specCanExpReal :: (Show t, Show (ExpType t), Show (DivType Integer (ExpType t)), Show (ExpType (AddType t t)), Show (MulType (ExpType t) (ExpType t)), Show (EnsureCN (ExpType t)), Arbitrary t, CanEnsureCN (ExpType t), CanTestCertainly (OrderCompareType Integer t), CanTestCertainly (OrderCompareType t Integer), CanTestCertainly (OrderCompareType (ExpType t) Integer), CanTestCertainly (EqCompareType (EnsureCN (ExpType t)) (DivType Integer (ExpType t))), CanTestCertainly (EqCompareType (ExpType (AddType t t)) (MulType (ExpType t) (ExpType t))), CanNeg t, HasEqAsymmetric (ExpType (AddType t t)) (MulType (ExpType t) (ExpType t)), HasEqAsymmetric (EnsureCN (ExpType t)) (DivType Integer (ExpType t)), HasOrderAsymmetric t Integer, HasOrderAsymmetric (ExpType t) Integer, HasOrderAsymmetric Integer t, CanAddAsymmetric t t, CanMulAsymmetric (ExpType t) (ExpType t), CanDiv Integer (ExpType t), CanExp t, CanExp (AddType t t), NegType t ~ t) => T t -> Spec

-- | A replacement for Prelude's <a>log</a>. If <tt>Floating t</tt>, then
--   one can use the default implementation to mirror Prelude's
--   <tt>log</tt>.
class CanLog t where type LogType t type LogType t = t log = log where {
    type family LogType t;
    type LogType t = t;
}
log :: CanLog t => t -> LogType t
log :: (CanLog t, LogType t ~ t, Floating t) => t -> t
type CanLogSameType t = (CanLog t, LogType t ~ t)
type CanLogCNSameType t = (CanLog t, LogType t ~ EnsureCN t)

-- | HSpec properties that each implementation of CanLog should satisfy.
specCanLogReal :: (Show t, Show (LogType t), Show (LogType (DivType Integer t)), Show (LogType (MulType t t)), Show (AddType (LogType t) (LogType t)), Show (LogType (ExpType t)), Arbitrary t, CanTestCertainly (OrderCompareType t Integer), CanTestCertainly (OrderCompareType (DivType Integer t) Integer), CanTestCertainly (EqCompareType (LogType (DivType Integer t)) (LogType t)), CanTestCertainly (OrderCompareType (MulType t t) Integer), CanTestCertainly (EqCompareType (LogType (MulType t t)) (AddType (LogType t) (LogType t))), CanTestCertainly (OrderCompareType Integer t), CanTestCertainly (EqCompareType (LogType (ExpType t)) t), CanNeg (LogType t), HasEqAsymmetric (LogType (DivType Integer t)) (LogType t), HasEqAsymmetric (LogType (MulType t t)) (AddType (LogType t) (LogType t)), HasEqAsymmetric (LogType (ExpType t)) t, HasOrderAsymmetric t Integer, HasOrderAsymmetric (DivType Integer t) Integer, HasOrderAsymmetric (MulType t t) Integer, HasOrderAsymmetric Integer t, CanAddAsymmetric (LogType t) (LogType t), CanMulAsymmetric t t, CanDiv Integer t, CanExp t, CanLog t, CanLog (DivType Integer t), CanLog (MulType t t), CanLog (ExpType t), LogType t ~ NegType (LogType t)) => T t -> Spec
powUsingExpLog :: (CanTestPosNeg t, CanEnsureCN t, CanEnsureCN (EnsureCN t), EnsureCN t ~ EnsureCN (EnsureCN t), CanLogCNSameType t, CanMulSameType t, CanMulSameType (EnsureCN t), CanExpSameType (EnsureCN t), CanTestInteger t, CanTestZero t, CanRecipCNSameType t) => t -> t -> t -> t -> EnsureCN t

-- | A replacement for Prelude's <a>cos</a> and <a>sin</a>. If <tt>Floating
--   t</tt>, then one can use the default implementation to mirror
--   Prelude's <tt>sin</tt>, <tt>cos</tt>.
class CanSinCos t where type SinCosType t type SinCosType t = t cos = cos sin = sin where {
    type family SinCosType t;
    type SinCosType t = t;
}
cos :: CanSinCos t => t -> SinCosType t
cos :: (CanSinCos t, SinCosType t ~ t, Floating t) => t -> t
sin :: CanSinCos t => t -> SinCosType t
sin :: (CanSinCos t, SinCosType t ~ t, Floating t) => t -> t
type CanSinCosSameType t = (CanSinCos t, SinCosType t ~ t)

-- | HSpec properties that each implementation of CanSinCos should satisfy.
--   
--   Derived partially from
--   <a>http://math.stackexchange.com/questions/1303044/axiomatic-definition-of-sin-and-cos</a>
specCanSinCosReal :: (Show t, Show (SinCosType t), Show (AddType (PowType (SinCosType t) Integer) (PowType (SinCosType t) Integer)), Show (SinCosType (SubType t t)), Show (SubType (MulType (SinCosType t) (SinCosType t)) (MulType (SinCosType t) (SinCosType t))), Show (AddType (MulType (SinCosType t) (SinCosType t)) (MulType (SinCosType t) (SinCosType t))), Show (DivType (SinCosType t) (SinCosType t)), Show (EnsureCN t), Arbitrary t, CanEnsureCN t, CanTestCertainly (OrderCompareType Integer (SinCosType t)), CanTestCertainly (OrderCompareType (SinCosType t) Integer), CanTestCertainly (EqCompareType (AddType (PowType (SinCosType t) Integer) (PowType (SinCosType t) Integer)) Integer), CanTestCertainly (EqCompareType (SinCosType (SubType t t)) (SubType (MulType (SinCosType t) (SinCosType t)) (MulType (SinCosType t) (SinCosType t)))), CanTestCertainly (EqCompareType (SinCosType (SubType t t)) (AddType (MulType (SinCosType t) (SinCosType t)) (MulType (SinCosType t) (SinCosType t)))), CanTestCertainly (OrderCompareType t Integer), CanTestCertainly (OrderCompareType t Rational), CanTestCertainly (OrderCompareType (SinCosType t) t), CanTestCertainly (OrderCompareType (EnsureCN t) (DivType (SinCosType t) (SinCosType t))), HasEqAsymmetric (AddType (PowType (SinCosType t) Integer) (PowType (SinCosType t) Integer)) Integer, HasEqAsymmetric (SinCosType (SubType t t)) (SubType (MulType (SinCosType t) (SinCosType t)) (MulType (SinCosType t) (SinCosType t))), HasEqAsymmetric (SinCosType (SubType t t)) (AddType (MulType (SinCosType t) (SinCosType t)) (MulType (SinCosType t) (SinCosType t))), HasOrderAsymmetric t Integer, HasOrderAsymmetric t Rational, HasOrderAsymmetric (SinCosType t) t, HasOrderAsymmetric (SinCosType t) Integer, HasOrderAsymmetric (EnsureCN t) (DivType (SinCosType t) (SinCosType t)), HasOrderAsymmetric Integer (SinCosType t), CanSub t t, CanSub (MulType (SinCosType t) (SinCosType t)) (MulType (SinCosType t) (SinCosType t)), CanAddAsymmetric (PowType (SinCosType t) Integer) (PowType (SinCosType t) Integer), CanAddAsymmetric (MulType (SinCosType t) (SinCosType t)) (MulType (SinCosType t) (SinCosType t)), CanPow (SinCosType t) Integer, CanMulAsymmetric (SinCosType t) (SinCosType t), CanDiv (SinCosType t) (SinCosType t), CanSinCos t, CanSinCos (SubType t t)) => T t -> Spec

-- | Approximate pi, synonym for Prelude's <a>pi</a>.
--   
--   We do not define (exect) <tt>pi</tt> in this package as we have no
--   type that can represent it exactly.
approxPi :: (Floating t) => t
instance Numeric.MixedTypes.Elementary.CanSqrt GHC.Types.Double
instance (Numeric.MixedTypes.Elementary.CanSqrt a, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Elementary.SqrtType a), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Elementary.CanSqrt (Control.CollectErrors.CollectErrors es a)
instance Numeric.MixedTypes.Elementary.CanExp GHC.Types.Double
instance (Numeric.MixedTypes.Elementary.CanExp a, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Elementary.ExpType a), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Elementary.CanExp (Control.CollectErrors.CollectErrors es a)
instance Numeric.MixedTypes.Elementary.CanLog GHC.Types.Double
instance (Numeric.MixedTypes.Elementary.CanLog a, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Elementary.LogType a), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Elementary.CanLog (Control.CollectErrors.CollectErrors es a)
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Elementary.CanSinCos GHC.Types.Double
instance (Numeric.MixedTypes.Elementary.CanSinCos a, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Elementary.SinCosType a), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Elementary.CanSinCos (Control.CollectErrors.CollectErrors es a)


-- | Instances for <a>Data.Complex</a>.
module Numeric.MixedTypes.Complex
tComplex :: T t -> T (Complex t)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer b0 => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Integer.Type.Integer => Numeric.MixedTypes.Eq.HasEqAsymmetric (Data.Complex.Complex a0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer b0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (Data.Complex.Complex b0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Integer.Type.Integer => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Data.Complex.Complex a0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer b0 => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (Data.Complex.Complex b0)
instance Numeric.MixedTypes.AddSub.CanSub a0 GHC.Integer.Type.Integer => Numeric.MixedTypes.AddSub.CanSub (Data.Complex.Complex a0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer b0 => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Integer.Type.Integer => Numeric.MixedTypes.Ring.CanMulAsymmetric (Data.Complex.Complex a0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer b0, Numeric.MixedTypes.Ring.CanMulAsymmetric b0 b0, Numeric.MixedTypes.AddSub.CanAddSameType (Numeric.MixedTypes.Ring.MulType b0 b0), Numeric.MixedTypes.Field.CanDiv (Numeric.MixedTypes.Ring.MulType GHC.Integer.Type.Integer b0) (Numeric.MixedTypes.Ring.MulType b0 b0)) => Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Field.CanDiv a0 GHC.Integer.Type.Integer => Numeric.MixedTypes.Field.CanDiv (Data.Complex.Complex a0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int b0 => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Types.Int => Numeric.MixedTypes.Eq.HasEqAsymmetric (Data.Complex.Complex a0) GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int b0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (Data.Complex.Complex b0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Types.Int => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Data.Complex.Complex a0) GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int b0 => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (Data.Complex.Complex b0)
instance Numeric.MixedTypes.AddSub.CanSub a0 GHC.Types.Int => Numeric.MixedTypes.AddSub.CanSub (Data.Complex.Complex a0) GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int b0 => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Types.Int => Numeric.MixedTypes.Ring.CanMulAsymmetric (Data.Complex.Complex a0) GHC.Types.Int
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int b0, Numeric.MixedTypes.Ring.CanMulAsymmetric b0 b0, Numeric.MixedTypes.AddSub.CanAddSameType (Numeric.MixedTypes.Ring.MulType b0 b0), Numeric.MixedTypes.Field.CanDiv (Numeric.MixedTypes.Ring.MulType GHC.Types.Int b0) (Numeric.MixedTypes.Ring.MulType b0 b0)) => Numeric.MixedTypes.Field.CanDiv GHC.Types.Int (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Field.CanDiv a0 GHC.Types.Int => Numeric.MixedTypes.Field.CanDiv (Data.Complex.Complex a0) GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational b0 => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Real.Rational => Numeric.MixedTypes.Eq.HasEqAsymmetric (Data.Complex.Complex a0) GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational b0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (Data.Complex.Complex b0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Real.Rational => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Data.Complex.Complex a0) GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational b0 => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (Data.Complex.Complex b0)
instance Numeric.MixedTypes.AddSub.CanSub a0 GHC.Real.Rational => Numeric.MixedTypes.AddSub.CanSub (Data.Complex.Complex a0) GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational b0 => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Real.Rational => Numeric.MixedTypes.Ring.CanMulAsymmetric (Data.Complex.Complex a0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational b0, Numeric.MixedTypes.Ring.CanMulAsymmetric b0 b0, Numeric.MixedTypes.AddSub.CanAddSameType (Numeric.MixedTypes.Ring.MulType b0 b0), Numeric.MixedTypes.Field.CanDiv (Numeric.MixedTypes.Ring.MulType GHC.Real.Rational b0) (Numeric.MixedTypes.Ring.MulType b0 b0)) => Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Field.CanDiv a0 GHC.Real.Rational => Numeric.MixedTypes.Field.CanDiv (Data.Complex.Complex a0) GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double b0 => Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a0 GHC.Types.Double => Numeric.MixedTypes.Eq.HasEqAsymmetric (Data.Complex.Complex a0) GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double b0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double (Data.Complex.Complex b0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Types.Double => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Data.Complex.Complex a0) GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double b0 => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double (Data.Complex.Complex b0)
instance Numeric.MixedTypes.AddSub.CanSub a0 GHC.Types.Double => Numeric.MixedTypes.AddSub.CanSub (Data.Complex.Complex a0) GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double b0 => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Types.Double => Numeric.MixedTypes.Ring.CanMulAsymmetric (Data.Complex.Complex a0) GHC.Types.Double
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double b0, Numeric.MixedTypes.Ring.CanMulAsymmetric b0 b0, Numeric.MixedTypes.AddSub.CanAddSameType (Numeric.MixedTypes.Ring.MulType b0 b0), Numeric.MixedTypes.Field.CanDiv (Numeric.MixedTypes.Ring.MulType GHC.Types.Double b0) (Numeric.MixedTypes.Ring.MulType b0 b0)) => Numeric.MixedTypes.Field.CanDiv GHC.Types.Double (Data.Complex.Complex b0)
instance Numeric.MixedTypes.Field.CanDiv a0 GHC.Types.Double => Numeric.MixedTypes.Field.CanDiv (Data.Complex.Complex a0) GHC.Types.Double
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer t => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer (Data.Complex.Complex t)
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int t => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int (Data.Complex.Complex t)
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational t => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational (Data.Complex.Complex t)
instance Numeric.MixedTypes.Literals.ConvertibleExactly t1 t2 => Numeric.MixedTypes.Literals.ConvertibleExactly (Data.Complex.Complex t1) (Data.Complex.Complex t2)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a b => Numeric.MixedTypes.Eq.HasEqAsymmetric (Data.Complex.Complex a) (Data.Complex.Complex b)
instance (Numeric.MixedTypes.Eq.CanTestInteger t, Numeric.MixedTypes.Eq.CanTestZero t) => Numeric.MixedTypes.Eq.CanTestInteger (Data.Complex.Complex t)
instance Numeric.MixedTypes.Bool.CanNeg t => Numeric.MixedTypes.Bool.CanNeg (Data.Complex.Complex t)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a b => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Data.Complex.Complex a) (Data.Complex.Complex b)
instance Numeric.MixedTypes.AddSub.CanSub a b => Numeric.MixedTypes.AddSub.CanSub (Data.Complex.Complex a) (Data.Complex.Complex b)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a b, Numeric.MixedTypes.AddSub.CanAddSameType (Numeric.MixedTypes.Ring.MulType a b), Numeric.MixedTypes.AddSub.CanSubSameType (Numeric.MixedTypes.Ring.MulType a b)) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Data.Complex.Complex a) (Data.Complex.Complex b)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a b, Numeric.MixedTypes.AddSub.CanAddSameType (Numeric.MixedTypes.Ring.MulType a b), Numeric.MixedTypes.AddSub.CanSubSameType (Numeric.MixedTypes.Ring.MulType a b), Numeric.MixedTypes.Ring.CanMulAsymmetric b b, Numeric.MixedTypes.AddSub.CanAddSameType (Numeric.MixedTypes.Ring.MulType b b), Numeric.MixedTypes.Field.CanDiv (Numeric.MixedTypes.Ring.MulType a b) (Numeric.MixedTypes.Ring.MulType b b)) => Numeric.MixedTypes.Field.CanDiv (Data.Complex.Complex a) (Data.Complex.Complex b)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric t t, Numeric.MixedTypes.AddSub.CanAddSameType (Numeric.MixedTypes.Ring.MulType t t), Numeric.MixedTypes.Elementary.CanSqrt (Numeric.MixedTypes.Ring.MulType t t)) => Numeric.MixedTypes.MinMaxAbs.CanAbs (Data.Complex.Complex t)
instance (Numeric.MixedTypes.Elementary.CanExp t, Numeric.MixedTypes.Elementary.CanSinCos t, Numeric.MixedTypes.Ring.CanMulAsymmetric (Numeric.MixedTypes.Elementary.ExpType t) (Numeric.MixedTypes.Elementary.SinCosType t)) => Numeric.MixedTypes.Elementary.CanExp (Data.Complex.Complex t)


-- | <h1>Main purpose</h1>
--   
--   This package provides a version of Prelude where unary and binary
--   operations such as <tt>not</tt>, <tt>+</tt>, <tt>==</tt> have their
--   result type derived from the parameter type(s), allowing, <i>e.g.</i>:
--   
--   <ul>
--   <li>Dividing an integer by an integer, giving a rational, wrapped in
--   the CN (ie Collecting NumErrors) monad:</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; :t let n = 1 :: Integer in n/(n+1)
--   ...CN Rational
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t 1/2
--   ...CN Rational
--   </pre>
--   
--   (Integer literals are always of type <tt>Integer</tt>, not <tt>Num t
--   =&gt; t</tt>.)
--   
--   <ul>
--   <li>Adding an integer and a rational, giving a rational:</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; :t (length [])+1/3
--   ...CN Rational
--   </pre>
--   
--   The <tt>CN</tt> monad is required because integer division can, in
--   general, fail as it is a partial operation:
--   
--   <pre>
--   &gt;&gt;&gt; 1/0
--   {[(ERROR,division by 0)]}
--   </pre>
--   
--   Note that when evaluating <tt>1/0</tt>, it evaluates to the error
--   value printed above. This is not an exception, but a special value.
--   
--   When one is certain the division is well defined, one can remove
--   <tt>CN</tt> in several ways:
--   
--   <pre>
--   &gt;&gt;&gt; :t (1%2)
--   ...Rational
--   </pre>
--   
--   Above we use (re-exported) Data.Ratio.(%), which means this trick
--   works only for Integers.
--   
--   <pre>
--   &gt;&gt;&gt; :t (1/!2)
--   ...Rational
--   </pre>
--   
--   This works also for non-integer division.
--   
--   <pre>
--   &gt;&gt;&gt; :t (~!) (1/2)
--   ...Rational
--   </pre>
--   
--   The (~!) operator removes CN from any type, throwing an exception if
--   there are collected errors.
--   
--   The operator (/!) stands for division which throws an exception is the
--   denominator is 0. It "propagates" any potential errors from the
--   sub-expressions. For example:
--   
--   <pre>
--   &gt;&gt;&gt; :t 1/!(1 - 1/n)
--   ...CN Rational
--   </pre>
--   
--   The above expression will throw an error exception when evaluated with
--   <tt>n=1</tt> but when <tt>n=0</tt>, it will not throw an excetion but
--   return an error value.
--   
--   <ul>
--   <li>taking natural, integer and fractional power using the same
--   operator:</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; :t 2^2
--   ...CN Integer
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t 2.0^(-2)
--   ...CN Rational
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t (double 2)^(1/!2)
--   ...Double
--   </pre>
--   
--   The following examples require package <a>aern2-real</a>:
--   
--   <pre>
--   &gt;&gt;&gt; :t 2^(1/2)
--   ...CauchyRealCN
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t pi
--   ...CauchyReal
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t sqrt 2
--   ...CauchyRealCN
--   </pre>
--   
--   <ul>
--   <li>comparing an integer with an (exact) real number, giving a
--   sequence of <tt>Maybe Bool</tt>:</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; let abs2 x = if x &lt; 0 then -x else x in (abs2 (pi - pi)) ? (bitsS 100)
--   [0 ± &lt;2^(-102)]
--   </pre>
--   
--   In the last example, <tt>if</tt> is overloaded so that it works for
--   conditions of other types than <tt>Bool</tt>. Here the condition has
--   the type <tt>Sequence (Maybe Bool)</tt>. The whole expression is the
--   sequence of balls in which those balls for which the condition is
--   inconclusive are the union of the balls computed by both branches.
--   
--   <h1>Type classes</h1>
--   
--   Arithmetic operations are provided via multi-parameter type classes
--   and the result type is given by associated type families. For example:
--   
--   <pre>
--   (+) :: (CanAddAsymmetric t1 t2) =&gt; t1 -&gt; t2 -&gt; AddType t1 t2
--   </pre>
--   
--   The type constraint <tt>CanAdd t1 t2</tt> implies both
--   <tt>CanAddAsymmetric t1 t2</tt> and <tt>CanAddAsymmetric t2 t1</tt>.
--   
--   For convenience there are other aggregate type constraints such as
--   <tt>CanAddThis t1 t2</tt>, which implies that the result is of type
--   <tt>t1</tt>, and <tt>CanAddSameType t</tt>, which is a shortcut for
--   <tt>CanAddThis t t</tt>.
--   
--   <h2>Testable specification</h2>
--   
--   The arithmetic type classes are accompanied by generic hspec test
--   suites, which are specialised to concrete instance types for their
--   testing. These test suites include the expected algebraic properties
--   of operations, such as commutativity and associativity of addition.
--   
--   <h1>Limitations</h1>
--   
--   <ul>
--   <li>Not all numerical operations are supported yet. Eg <tt>tan</tt>,
--   <tt>atan</tt> are missing at the moment.</li>
--   </ul>
--   
--   <ul>
--   <li>Inferred types can be very large. Eg for <tt>f a b c = sqrt (a + b
--   * c + 1)</tt> the inferred type is:</li>
--   </ul>
--   
--   <pre>
--   f: (CanMulAsymmetric t1 t2, CanAddAsymmetric t4 (MulType t1 t2),
--       CanAddAsymmetric (AddType t4 (MulType t1 t2)) Integer,
--       CanSqrt (AddType (AddType t4 (MulType t1 t2)) Integer)) =&gt;
--      t4
--      -&gt; t1
--      -&gt; t2
--      -&gt; SqrtType (AddType (AddType t4 (MulType t1 t2)) Integer)
--   </pre>
--   
--   <ul>
--   <li>Due to limitations of some versions of ghc, type inferrence
--   sometimes fails. Eg <tt>add1 = (+ 1)</tt> fails (eg with ghc 8.0.2)
--   unless we explicitly declare the type <tt>add1 :: (CanAdd Integer t)
--   =&gt; t -&gt; AddType t Integer</tt> or use an explicit parameter, eg
--   <tt>add1 x = x + 1</tt>.</li>
--   </ul>
--   
--   <h1>Origin</h1>
--   
--   The idea of having numeric expressions in Haskell with types derived
--   bottom-up was initially suggested and implemented by Pieter Collins.
--   This version is a fresh rewrite by Michal Konečný.
--   
--   <h1>More details</h1>
--   
--   This module facilitates a single-line import for the package
--   mixed-types-num. See the re-exported modules for further details.
module MixedTypesNumPrelude

-- | Forms the ratio of two integral numbers.
(%) :: Integral a => a -> a -> Ratio a
infixl 7 %
