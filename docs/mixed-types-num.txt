-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Alternative Prelude with numeric and logic expressions typed bottom-up
--   
--   This package provides a version of Prelude where unary and binary
--   operations such as <tt>not</tt>, <tt>+</tt>, <tt>==</tt> have their
--   result type derived from the parameter type(s).
--   
--   See module <a>Numeric.MixedTypes</a> for further documentation.
@package mixed-types-num
@version 0.1.0.1


-- | Prelude without operations that clash with MixedTypes
module Numeric.MixedTypes.PreludeHiding


-- | This module defines fixed-type integer and rational literals. This is
--   useful when deriving the type of an expression bottom-up. Eg we would
--   not be able to write <tt>1 &lt; x</tt> when the type of <tt>&lt;</tt>
--   does not force the two sides to be of the same type. We would need to
--   write eg <tt>(1::Integer) &lt; x</tt> with Prelude's generic literals.
--   
--   Moreover, convenient conversion functions are provided for the most
--   common numeric types. Thus one can say eg:
--   
--   <ul>
--   <li><pre>take (int 1)</pre></li>
--   <li><tt>integer (length list)</tt>.</li>
--   <li><pre>double 0.5</pre></li>
--   </ul>
--   
--   To avoid integer overflow, no aritmetic operations return <a>Int</a>.
--   Nevertheless, one can usually mix <a>Int</a> with other types in
--   expressions.
--   
--   Any approximate arithmetic, ie arithmetic involving Doubles, returns
--   values of type <a>Double</a>. <a>Double</a> values cannot be easily
--   converted to exact types such as <a>Rational</a> or <a>Integer</a> so
--   that all such conversions are clearly visible as labelled as inexact.
module Numeric.MixedTypes.Literals

-- | Replacement for <a>fromInteger</a> using the RebindableSyntax
--   extension. This version of fromInteger arranges that integer literals
--   are always of type <a>Integer</a>.
fromInteger :: Integer -> Integer

-- | Replacement for <a>fromRational</a> using the RebindableSyntax
--   extension. This version of fromRational arranges that rational
--   literals are always of type <a>Rational</a>.
fromRational :: Rational -> Rational

-- | Restore if-then-else with RebindableSyntax
ifThenElse :: Bool -> t -> t -> t
type CanBeInteger t = ConvertibleExactly t Integer
integer :: (CanBeInteger t) => t -> Integer
integers :: (CanBeInteger t) => [t] -> [Integer]
type HasIntegers t = ConvertibleExactly Integer t
fromInteger_ :: (HasIntegers t) => Integer -> t
type CanBeInt t = ConvertibleExactly t Int
int :: (CanBeInt t) => t -> Int
ints :: (CanBeInt t) => [t] -> [Int]
type CanBeRational t = ConvertibleExactly t Rational
rational :: (CanBeRational t) => t -> Rational
rationals :: (CanBeRational t) => [t] -> [Rational]
type HasRationals t = ConvertibleExactly Rational t
fromRational_ :: (HasRationals t) => Rational -> t
type CanBeDouble t = Convertible t Double
double :: (CanBeDouble t) => t -> Double
doubles :: (CanBeDouble t) => [t] -> [Double]

-- | Define our own ConvertibleExactly since convertible is too relaxed for
--   us. For example, convertible allows conversion from Rational to
--   Integer, rounding to nearest integer. We prefer to allow only exact
--   conversions.
class ConvertibleExactly t1 t2 where safeConvertExactly = safeConvert
safeConvertExactly :: ConvertibleExactly t1 t2 => t1 -> ConvertResult t2
safeConvertExactly :: (ConvertibleExactly t1 t2, Convertible t1 t2) => t1 -> ConvertResult t2
convertExactly :: (ConvertibleExactly t1 t2) => t1 -> t2

-- | The result of a safe conversion via <a>safeConvert</a>.
type ConvertResult a = Either ConvertError a

-- | How we indicate that there was an error.
data ConvertError :: *
convError :: (Show a, Typeable * a, Typeable * b) => String -> a -> ConvertResult b
(!!) :: (CanBeInteger t) => [a] -> t -> a

-- | HSpec properties that each implementation of CanBeInteger should
--   satisfy.
specCanBeInteger :: (CanBeInteger t, Show t, Arbitrary t) => T t -> Spec
printArgsIfFails2 :: (Testable prop, Show a, Show b) => String -> (a -> b -> prop) -> (a -> b -> Property)

-- | A runtime representative of type <tt>t</tt>. Used for specialising
--   polymorphic tests to concrete types.
data T t
T :: String -> T t
tInt :: T Int
tInteger :: T Integer
tRational :: T Rational
tDouble :: T Double
tBool :: T Bool
tMaybeBool :: T (Maybe Bool)
tMaybeMaybeBool :: T (Maybe (Maybe Bool))
convertFirst :: (ConvertibleExactly a b) => (b -> b -> c) -> (a -> b -> c)
convertSecond :: (ConvertibleExactly b a) => (a -> a -> c) -> (a -> b -> c)
convertFirstUsing :: (a -> b -> b) -> (b -> b -> c) -> (a -> b -> c)
convertSecondUsing :: (a -> b -> a) -> (a -> a -> c) -> (a -> b -> c)
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Double GHC.Types.Double


module Numeric.MixedTypes.Bool

-- | A type constraint synonym that stipulates that the type behaves very
--   much like Bool, except it does not necessarily satisfy the law of
--   excluded middle, which means that the type can contain a "do-not-know"
--   value.
--   
--   Examples: <tt>Bool</tt>, <tt>Maybe Bool</tt>, <tt>Maybe (Maybe
--   Bool)</tt>
type IsBool t = (HasBools t, CanNegSameType t, CanAndOrSameType t)

-- | HSpec properties that each implementation of IsBool should satisfy.
specIsBool :: (IsBool t, CanTestCertainly t, Show t, Serial IO t) => T t -> Spec
type HasBools t = ConvertibleExactly Bool t

-- | Tests for truth or falsity. Beware, when <tt>isCertainlyTrue</tt>
--   returns <tt>False</tt>, it does not mean that the proposition is
--   false. It usually means that we failed to prove the proposition.
class (HasBools t) => CanTestCertainly t
isCertainlyTrue :: CanTestCertainly t => t -> Bool
isCertainlyFalse :: CanTestCertainly t => t -> Bool

-- | HSpec properties that each implementation of CanTestCertainly should
--   satisfy.
specCanTestCertainly :: (CanTestCertainly t) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanTestCertainlyX t = (CanTestCertainly t, Show t, Serial IO t)
isNotTrue :: (CanTestCertainly t) => t -> Bool
isNotFalse :: (CanTestCertainly t) => t -> Bool

-- | If l is certainly True, then r is also certainly True.
stronglyImplies :: (CanTestCertainly t1, CanTestCertainly t2) => t1 -> t2 -> Bool
stronglyEquivalentTo :: (CanTestCertainly t1, CanTestCertainly t2) => t1 -> t2 -> Bool

-- | If l is certainly True, then r is not certainly False.
weaklyImplies :: (CanTestCertainly t1, CanTestCertainly t2) => t1 -> t2 -> Bool
weaklyEquivalentTo :: (CanTestCertainly t1, CanTestCertainly t2) => t1 -> t2 -> Bool

-- | This is negation is both the numeric negation as well as the Boolean
--   negation. Example of non-standard Boolean negation:
--   
--   <pre>
--   negate (Just True) = Just False
--   
--   </pre>
class CanNeg t where type NegType t type NegType t = t where {
    type family NegType t;
    type NegType t = t;
}
negate :: CanNeg t => t -> NegType t

-- | A synonym of <a>negate</a>.
not :: (CanNeg t) => t -> NegType t
type CanNegSameType t = (CanNeg t, NegType t ~ t)

-- | HSpec properties that each Boolean implementation of CanNeg should
--   satisfy.
specCanNegBool :: (CanNegBoolX t, CanNegBoolX (NegType t)) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanNegBoolX t = (CanNeg t, CanTestCertainlyX t, CanTestCertainlyX (NegType t))
type CanAndOr t1 t2 = (CanAndOrAsymmetric t1 t2, CanAndOrAsymmetric t2 t1, AndOrType t1 t2 ~ AndOrType t2 t1)

-- | Binary logical <a>and</a> and <a>or</a> for generalised Booleans. For
--   example:
--   
--   <pre>
--   (Just True) &amp;&amp; False = Just False
--   (Just (Just True)) || False = (Just (Just True))
--   
--   </pre>
class CanAndOrAsymmetric t1 t2 where type AndOrType t1 t2 where {
    type family AndOrType t1 t2;
}
and2 :: CanAndOrAsymmetric t1 t2 => t1 -> t2 -> AndOrType t1 t2
or2 :: CanAndOrAsymmetric t1 t2 => t1 -> t2 -> AndOrType t1 t2

-- | A synonym of <a>and2</a>.
(&&) :: (CanAndOrAsymmetric a b) => a -> b -> AndOrType a b
infixr 3 &&

-- | A synonym of <a>or2</a>.
(||) :: (CanAndOrAsymmetric a b) => a -> b -> AndOrType a b
infixr 2 ||
type CanAndOrWith t1 t2 = (CanAndOr t1 t2, AndOrType t1 t2 ~ t1)
type CanAndOrSameType t = CanAndOrWith t t
and :: (CanAndOrSameType t, CanTestCertainly t) => [t] -> t
or :: (CanAndOrSameType t, CanTestCertainly t) => [t] -> t

-- | HSpec properties that each implementation of CanAndOr should satisfy.
specCanAndOr :: (CanAndOrX t1 t1, CanAndOrX t1 t2, CanAndOrX t2 t1, CanAndOrX t1 t3, CanAndOrX t2 t3, CanAndOrX (AndOrType t1 t2) t3, CanAndOrX t1 (AndOrType t2 t3), CanAndOrX (AndOrType t1 t2) (AndOrType t1 t3)) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of CanAndOr should satisfy.
specCanAndOrNotMixed :: (CanAndOrX t t, CanAndOrX (AndOrType t t) t, CanAndOrX t (AndOrType t t), CanAndOrX (AndOrType t t) (AndOrType t t)) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanAndOrX t1 t2 = (CanAndOr t1 t2, CanNeg t1, CanNeg t2, CanAndOr (NegType t1) t2, CanAndOr t1 (NegType t2), CanAndOr (NegType t1) (NegType t2), CanTestCertainlyX t1, CanTestCertainlyX t2, CanTestCertainlyX (AndOrType t1 t2), CanTestCertainlyX (NegType (AndOrType t1 t2)), CanTestCertainlyX (AndOrType (NegType t1) t2), CanTestCertainlyX (AndOrType t1 (NegType t2)), CanTestCertainlyX (AndOrType (NegType t1) (NegType t2)))
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool GHC.Types.Bool
instance Numeric.MixedTypes.Bool.CanTestCertainly GHC.Types.Bool
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool t => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool (GHC.Base.Maybe t)
instance Numeric.MixedTypes.Bool.CanTestCertainly t => Numeric.MixedTypes.Bool.CanTestCertainly (GHC.Base.Maybe t)
instance Numeric.MixedTypes.Bool.CanNeg GHC.Types.Bool
instance Numeric.MixedTypes.Bool.CanNeg t => Numeric.MixedTypes.Bool.CanNeg (GHC.Base.Maybe t)
instance Numeric.MixedTypes.Bool.CanAndOrAsymmetric GHC.Types.Bool GHC.Types.Bool
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric t1 t2, Numeric.MixedTypes.Bool.CanTestCertainly t1, Numeric.MixedTypes.Bool.CanTestCertainly t2, Numeric.MixedTypes.Bool.CanTestCertainly (Numeric.MixedTypes.Bool.AndOrType t1 t2)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric (GHC.Base.Maybe t1) (GHC.Base.Maybe t2)
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric GHC.Types.Bool t2, Numeric.MixedTypes.Bool.CanTestCertainly t2, Numeric.MixedTypes.Bool.CanTestCertainly (Numeric.MixedTypes.Bool.AndOrType GHC.Types.Bool t2)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric GHC.Types.Bool (GHC.Base.Maybe t2)
instance (Numeric.MixedTypes.Bool.CanAndOrAsymmetric t1 GHC.Types.Bool, Numeric.MixedTypes.Bool.CanTestCertainly t1, Numeric.MixedTypes.Bool.CanTestCertainly (Numeric.MixedTypes.Bool.AndOrType t1 GHC.Types.Bool)) => Numeric.MixedTypes.Bool.CanAndOrAsymmetric (GHC.Base.Maybe t1) GHC.Types.Bool


module Numeric.MixedTypes.Eq
type HasEq t1 t2 = (HasEqAsymmetric t1 t2, HasEqAsymmetric t2 t1, EqCompareType t1 t2 ~ EqCompareType t2 t1)
class (IsBool (EqCompareType a b)) => HasEqAsymmetric a b where type EqCompareType a b type EqCompareType a b = Bool equalTo = (==) notEqualTo a b = not $ equalTo a b where {
    type family EqCompareType a b;
    type EqCompareType a b = Bool;
}
equalTo :: HasEqAsymmetric a b => a -> b -> (EqCompareType a b)
equalTo :: (HasEqAsymmetric a b, EqCompareType a b ~ Bool, a ~ b, Eq a) => a -> b -> Bool
notEqualTo :: HasEqAsymmetric a b => a -> b -> (EqCompareType a b)
notEqualTo :: (HasEqAsymmetric a b, CanNegSameType (EqCompareType a b)) => a -> b -> (EqCompareType a b)
(==) :: (HasEqAsymmetric a b) => a -> b -> EqCompareType a b
infix 4 ==
(/=) :: (HasEqAsymmetric a b) => a -> b -> EqCompareType a b
infix 4 /=
type HasEqCertainly t1 t2 = (HasEq t1 t2, CanTestCertainly (EqCompareType t1 t2))
type HasEqCertainlyAsymmetric t1 t2 = (HasEqAsymmetric t1 t2, CanTestCertainly (EqCompareType t1 t2))
notCertainlyDifferentFrom :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
certainlyEqualTo :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
certainlyNotEqualTo :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
(?==?) :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?==?
(!==!) :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !==!
(!/=!) :: (HasEqCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !/=!

-- | HSpec properties that each implementation of HasEq should satisfy.
specHasEq :: (HasEqX t1 t1, HasEqX t1 t2, HasEqX t2 t1, HasEqX t1 t3, HasEqX t2 t3, CanAndOrX (EqCompareType t1 t2) (EqCompareType t2 t3)) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of HasEq should satisfy.
specHasEqNotMixed :: (HasEqX t t, CanAndOrX (EqCompareType t t) (EqCompareType t t)) => T t -> Spec

-- | Compound type constraint useful for test definition.
type HasEqX t1 t2 = (HasEqCertainly t1 t2, Show t1, Arbitrary t1, Show t2, Arbitrary t2)

-- | HSpec property of there-and-back conversion.
specConversion :: (Arbitrary t1, Show t1, HasEqCertainly t1 t1) => T t1 -> T t2 -> (t1 -> t2) -> (t2 -> t1) -> Spec
class CanTestFinite t where isNaN = isNaN isInfinite = isInfinite isFinite x = (not $ isNaN x) && (not $ isInfinite x)
isNaN :: CanTestFinite t => t -> Bool
isNaN :: (CanTestFinite t, RealFloat t) => t -> Bool
isInfinite :: CanTestFinite t => t -> Bool
isInfinite :: (CanTestFinite t, RealFloat t) => t -> Bool
isFinite :: CanTestFinite t => t -> Bool
class CanTestInteger t where certainlyInteger s = case certainlyIntegerGetIt s of { Just _ -> True _ -> False }
certainlyNotInteger :: CanTestInteger t => t -> Bool
certainlyInteger :: CanTestInteger t => t -> Bool
certainlyIntegerGetIt :: CanTestInteger t => t -> Maybe Integer
class CanTestZero t where isCertainlyZero a = isCertainlyTrue (a == 0) isNonZero a = isCertainlyTrue (a /= 0)
isCertainlyZero :: CanTestZero t => t -> Bool
isNonZero :: CanTestZero t => t -> Bool
isCertainlyZero :: (CanTestZero t, HasEqCertainly t Integer) => t -> Bool
isNonZero :: (CanTestZero t, HasEqCertainly t Integer) => t -> Bool

-- | HSpec properties that each implementation of CanTestZero should
--   satisfy.
specCanTestZero :: (CanTestZero t, ConvertibleExactly Integer t) => T t -> Spec
class CanPickNonZero t where pickNonZero list = case aux list of { Just result -> result Nothing -> error $ "pickNonZero: failed to find a non-zero element in " ++ show (map fst list) } where aux ((a, b) : rest) | isNonZero a = Just (a, b) | otherwise = aux rest aux [] = Nothing

-- | Given a list <tt>[(a1,b1),(a2,b2),...]</tt> and assuming that at least
--   one of <tt>a1,a2,...</tt> is non-zero, pick one of them and return the
--   corresponding pair <tt>(ai,bi)</tt>.
--   
--   If none of <tt>a1,a2,...</tt> is zero, either throws an exception or
--   loops forever.
--   
--   The default implementation is based on a <a>CanTestZero</a> instance
--   and is not parallel.
pickNonZero :: CanPickNonZero t => [(t, s)] -> (t, s)

-- | Given a list <tt>[(a1,b1),(a2,b2),...]</tt> and assuming that at least
--   one of <tt>a1,a2,...</tt> is non-zero, pick one of them and return the
--   corresponding pair <tt>(ai,bi)</tt>.
--   
--   If none of <tt>a1,a2,...</tt> is zero, either throws an exception or
--   loops forever.
--   
--   The default implementation is based on a <a>CanTestZero</a> instance
--   and is not parallel.
pickNonZero :: (CanPickNonZero t, CanTestZero t, Show t) => [(t, s)] -> (t, s)

-- | HSpec properties that each implementation of CanPickNonZero should
--   satisfy.
specCanPickNonZero :: (CanPickNonZero t, CanTestZero t, ConvertibleExactly Integer t, Show t, Arbitrary t) => T t -> Spec
instance Numeric.MixedTypes.Eq.HasEqAsymmetric () ()
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Bool GHC.Types.Bool
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Char GHC.Types.Char
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Double GHC.Types.Int
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a1 b1, Numeric.MixedTypes.Eq.HasEqAsymmetric a2 b2, Numeric.MixedTypes.Bool.CanAndOrAsymmetric (Numeric.MixedTypes.Eq.EqCompareType a1 b1) (Numeric.MixedTypes.Eq.EqCompareType a2 b2), Numeric.MixedTypes.Bool.IsBool (Numeric.MixedTypes.Bool.AndOrType (Numeric.MixedTypes.Eq.EqCompareType a1 b1) (Numeric.MixedTypes.Eq.EqCompareType a2 b2))) => Numeric.MixedTypes.Eq.HasEqAsymmetric (a1, a2) (b1, b2)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric ((a1, a2), a3) ((b1, b2), b3) => Numeric.MixedTypes.Eq.HasEqAsymmetric (a1, a2, a3) (b1, b2, b3)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric ((a1, a2, a3), a4) ((b1, b2, b3), b4) => Numeric.MixedTypes.Eq.HasEqAsymmetric (a1, a2, a3, a4) (b1, b2, b3, b4)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric ((a1, a2, a3, a4), a5) ((b1, b2, b3, b4), b5) => Numeric.MixedTypes.Eq.HasEqAsymmetric (a1, a2, a3, a4, a5) (b1, b2, b3, b4, b5)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a b => Numeric.MixedTypes.Eq.HasEqAsymmetric [a] [b]
instance Numeric.MixedTypes.Eq.HasEqAsymmetric a b => Numeric.MixedTypes.Eq.HasEqAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance Numeric.MixedTypes.Eq.CanTestFinite GHC.Types.Double
instance Numeric.MixedTypes.Eq.CanTestFinite GHC.Real.Rational
instance Numeric.MixedTypes.Eq.CanTestInteger GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.CanTestInteger GHC.Types.Int
instance Numeric.MixedTypes.Eq.CanTestInteger GHC.Real.Rational
instance Numeric.MixedTypes.Eq.CanTestInteger GHC.Types.Double
instance Numeric.MixedTypes.Eq.CanTestZero GHC.Types.Int
instance Numeric.MixedTypes.Eq.CanTestZero GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.CanTestZero GHC.Real.Rational
instance Numeric.MixedTypes.Eq.CanTestZero GHC.Types.Double
instance Numeric.MixedTypes.Eq.CanPickNonZero GHC.Types.Int
instance Numeric.MixedTypes.Eq.CanPickNonZero GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.CanPickNonZero GHC.Real.Rational


module Numeric.MixedTypes.Ord
type HasOrder t1 t2 = (HasOrderAsymmetric t1 t2, HasOrderAsymmetric t2 t1, OrderCompareType t1 t2 ~ OrderCompareType t2 t1)
class (IsBool (OrderCompareType a b)) => HasOrderAsymmetric a b where type OrderCompareType a b type OrderCompareType a b = Bool lessThan = (<) greaterThan a b = lessThan b a leq = (<=) geq a b = leq b a where {
    type family OrderCompareType a b;
    type OrderCompareType a b = Bool;
}
lessThan :: HasOrderAsymmetric a b => a -> b -> (OrderCompareType a b)
lessThan :: (HasOrderAsymmetric a b, OrderCompareType a b ~ Bool, a ~ b, Ord a) => a -> b -> Bool
greaterThan :: HasOrderAsymmetric a b => a -> b -> (OrderCompareType a b)
greaterThan :: (HasOrderAsymmetric a b, HasOrder b a, OrderCompareType b a ~ OrderCompareType a b) => a -> b -> (OrderCompareType a b)
leq :: HasOrderAsymmetric a b => a -> b -> (OrderCompareType a b)
leq :: (HasOrderAsymmetric a b, OrderCompareType a b ~ Bool, a ~ b, Ord a) => a -> b -> Bool
geq :: HasOrderAsymmetric a b => a -> b -> (OrderCompareType a b)
geq :: (HasOrderAsymmetric a b, HasOrder b a, OrderCompareType b a ~ OrderCompareType a b) => a -> b -> (OrderCompareType a b)
(>) :: (HasOrderAsymmetric a b) => a -> b -> OrderCompareType a b
infix 4 >
(<) :: (HasOrderAsymmetric a b) => a -> b -> OrderCompareType a b
infix 4 <
(<=) :: (HasOrderAsymmetric a b) => a -> b -> OrderCompareType a b
infix 4 <=
(>=) :: (HasOrderAsymmetric a b) => a -> b -> OrderCompareType a b
infix 4 >=
type HasOrderCertainlyAsymmetric t1 t2 = (HasOrderAsymmetric t1 t2, CanTestCertainly (OrderCompareType t1 t2))
type HasOrderCertainly t1 t2 = (HasOrder t1 t2, CanTestCertainly (OrderCompareType t1 t2))
(?<=?) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?<=?
(?<?) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?<?
(?>=?) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?>=?
(?>?) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 ?>?
(!<=!) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !<=!
(!<!) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !<!
(!>=!) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !>=!
(!>!) :: (HasOrderCertainlyAsymmetric a b) => a -> b -> Bool
infix 4 !>!

-- | HSpec properties that each implementation of <a>HasOrder</a> should
--   satisfy.
specHasOrder :: (HasOrderX t1 t1, HasOrderX t1 t2, HasOrderX t1 t3, HasOrderX t2 t3, CanAndOrX (OrderCompareType t1 t2) (OrderCompareType t2 t3)) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of <a>HasOrder</a> should
--   satisfy.
specHasOrderNotMixed :: (HasOrderX t t, CanAndOrX (OrderCompareType t t) (OrderCompareType t t)) => T t -> Spec

-- | Compound type constraint useful for test definition.
type HasOrderX t1 t2 = (HasOrderCertainly t1 t2, Show t1, Arbitrary t1, Show t2, Arbitrary t2)
class CanTestPosNeg t where isCertainlyPositive a = isCertainlyTrue $ a > 0 isCertainlyNonNegative a = isCertainlyTrue $ a >= 0 isCertainlyNegative a = isCertainlyTrue $ a < 0 isCertainlyNonPositive a = isCertainlyTrue $ a <= 0
isCertainlyPositive :: CanTestPosNeg t => t -> Bool
isCertainlyNonNegative :: CanTestPosNeg t => t -> Bool
isCertainlyNegative :: CanTestPosNeg t => t -> Bool
isCertainlyNonPositive :: CanTestPosNeg t => t -> Bool
isCertainlyPositive :: (CanTestPosNeg t, HasOrderCertainly t Integer) => t -> Bool
isCertainlyNonNegative :: (CanTestPosNeg t, HasOrderCertainly t Integer) => t -> Bool
isCertainlyNegative :: (CanTestPosNeg t, HasOrderCertainly t Integer) => t -> Bool
isCertainlyNonPositive :: (CanTestPosNeg t, HasOrderCertainly t Integer) => t -> Bool
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.Ord.CanTestPosNeg GHC.Types.Int
instance Numeric.MixedTypes.Ord.CanTestPosNeg GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.CanTestPosNeg GHC.Real.Rational
instance Numeric.MixedTypes.Ord.CanTestPosNeg GHC.Types.Double


module Numeric.MixedTypes.MinMaxAbs
type CanMinMax t1 t2 = (CanMinMaxAsymmetric t1 t2, CanMinMaxAsymmetric t2 t1, MinMaxType t1 t2 ~ MinMaxType t2 t1)

-- | A replacement for Prelude's <a>min</a> and <a>max</a>. If <tt>t1 =
--   t2</tt> and <tt>Ord t1</tt>, then one can use the default
--   implementation to mirror Prelude's <tt>min</tt> and <tt>max</tt>.
class CanMinMaxAsymmetric t1 t2 where type MinMaxType t1 t2 type MinMaxType t1 t2 = t1 min = min max = max where {
    type family MinMaxType t1 t2;
    type MinMaxType t1 t2 = t1;
}
min :: CanMinMaxAsymmetric t1 t2 => t1 -> t2 -> MinMaxType t1 t2
max :: CanMinMaxAsymmetric t1 t2 => t1 -> t2 -> MinMaxType t1 t2
min :: (CanMinMaxAsymmetric t1 t2, MinMaxType t1 t2 ~ t1, t1 ~ t2, Ord t1) => t1 -> t1 -> t1
max :: (CanMinMaxAsymmetric t1 t2, MinMaxType t1 t2 ~ t1, t1 ~ t2, Ord t1) => t1 -> t1 -> t1
type CanMinMaxThis t1 t2 = (CanMinMax t1 t2, MinMaxType t1 t2 ~ t1)
type CanMinMaxSameType t = CanMinMaxThis t t
minimum :: (CanMinMaxSameType t) => [t] -> t
maximum :: (CanMinMaxSameType t) => [t] -> t

-- | HSpec properties that each implementation of CanMinMax should satisfy.
specCanMinMax :: (CanMinMaxXX t1 t1, CanMinMaxXX t1 t2, CanMinMaxXX t1 t3, CanMinMaxXX t2 t3, CanMinMaxXX t1 (MinMaxType t2 t3), CanMinMaxXX (MinMaxType t1 t2) t3, HasEqCertainly (MinMaxType t1 (MinMaxType t2 t3)) (MinMaxType (MinMaxType t1 t2) t3)) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of CanMinMax should satisfy.
specCanMinMaxNotMixed :: (CanMinMaxXX t t, CanMinMaxXX t (MinMaxType t t), HasEq (MinMaxType (MinMaxType t t) t) (MinMaxType t (MinMaxType t t))) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanMinMaxX t1 t2 = (CanMinMax t1 t2, Show t1, Arbitrary t1, Show t2, Arbitrary t2, Show (MinMaxType t1 t2), HasEqCertainly t1 t1, HasEqCertainly t2 t2, HasEqCertainly t1 (MinMaxType t1 t2), HasEqCertainly t2 (MinMaxType t1 t2), HasEqCertainly (MinMaxType t1 t2) (MinMaxType t1 t2), HasOrderCertainly t1 (MinMaxType t1 t2), HasOrderCertainly t2 (MinMaxType t1 t2), HasOrderCertainly (MinMaxType t1 t2) (MinMaxType t1 t2))

-- | Compound type constraint useful for test definition.
type CanMinMaxXX t1 t2 = (CanMinMaxX t1 t2, HasEqCertainly (MinMaxType t1 t2) (MinMaxType t2 t1))

-- | A replacement for Prelude's <a>abs</a>. If <tt>Num t</tt>, then one
--   can use the default implementation to mirror Prelude's <tt>abs</tt>.
class CanAbs t where type AbsType t type AbsType t = t abs = abs where {
    type family AbsType t;
    type AbsType t = t;
}
abs :: CanAbs t => t -> AbsType t
abs :: (CanAbs t, AbsType t ~ t, Num t) => t -> t
type CanAbsSameType t = (CanAbs t, AbsType t ~ t)

-- | HSpec properties that each numeric implementation of CanNeg should
--   satisfy.
specCanNegNum :: (CanNegX t, CanNegX (NegType t), HasEqCertainly t (NegType (NegType t)), ConvertibleExactly Integer t, HasEqCertainly t t, HasEqCertainly t (NegType t), CanTestPosNeg t, CanTestPosNeg (NegType t)) => T t -> Spec

-- | HSpec properties that each implementation of CanAbs should satisfy.
specCanAbs :: (CanAbsX t, CanAbsX (AbsType t)) => T t -> Spec
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a b => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric [a] [b]
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a b => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance Numeric.MixedTypes.Bool.CanNeg GHC.Types.Int
instance Numeric.MixedTypes.Bool.CanNeg GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Bool.CanNeg GHC.Real.Rational
instance Numeric.MixedTypes.Bool.CanNeg GHC.Types.Double
instance Numeric.MixedTypes.MinMaxAbs.CanAbs GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanAbs GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanAbs GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanAbs GHC.Types.Double


module Numeric.MixedTypes.AddSub
type CanAdd t1 t2 = (CanAddAsymmetric t1 t2, CanAddAsymmetric t2 t1, AddType t1 t2 ~ AddType t2 t1)

-- | A replacement for Prelude's <a>+</a>. If <tt>t1 = t2</tt> and <tt>Num
--   t1</tt>, then one can use the default implementation to mirror
--   Prelude's <tt>+</tt>.
class CanAddAsymmetric t1 t2 where type AddType t1 t2 type AddType t1 t2 = t1 add = (+) where {
    type family AddType t1 t2;
    type AddType t1 t2 = t1;
}
add :: CanAddAsymmetric t1 t2 => t1 -> t2 -> AddType t1 t2
add :: (CanAddAsymmetric t1 t2, AddType t1 t2 ~ t1, t1 ~ t2, Num t1) => t1 -> t1 -> t1
type CanAddThis t1 t2 = (CanAdd t1 t2, AddType t1 t2 ~ t1)
type CanAddSameType t = CanAddThis t t
(+) :: (CanAddAsymmetric t1 t2) => t1 -> t2 -> AddType t1 t2
infixl 6 +
sum :: (CanAddSameType t, ConvertibleExactly Integer t) => [t] -> t

-- | HSpec properties that each implementation of CanAdd should satisfy.
specCanAdd :: (CanAddXX t1 t1, CanAddXX t1 t2, CanAddXX t1 t3, CanAddXX t2 t3, CanAddXX t1 (AddType t2 t3), CanAddXX (AddType t1 t2) t3, ConvertibleExactly Integer t1, CanTestPosNeg t1, HasEqCertainly (AddType t1 (AddType t2 t3)) (AddType (AddType t1 t2) t3)) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of CanAdd should satisfy.
specCanAddNotMixed :: (CanAddXX t t, CanAddXX t (AddType t t), ConvertibleExactly Integer t, CanTestPosNeg t) => T t -> Spec

-- | HSpec properties that each implementation of CanAddSameType should
--   satisfy.
specCanAddSameType :: (ConvertibleExactly Integer t, Show t, HasEqCertainly t t, CanAddSameType t) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanAddX t1 t2 = (CanAdd t1 t2, Show t1, Arbitrary t1, Show t2, Arbitrary t2, Show (AddType t1 t2), HasEqCertainly t1 (AddType t1 t2), HasEqCertainly t2 (AddType t1 t2), HasEqCertainly (AddType t1 t2) (AddType t1 t2), HasOrderCertainly t1 (AddType t1 t2), HasOrderCertainly t2 (AddType t1 t2), HasOrderCertainly (AddType t1 t2) (AddType t1 t2))

-- | Compound type constraint useful for test definition.
type CanAddXX t1 t2 = (CanAddX t1 t2, HasEqCertainly (AddType t1 t2) (AddType t2 t1))

-- | A replacement for Prelude's binary <a>-</a>.
--   
--   If <tt>CanNeg t2</tt> and <tt>CanAdd t1 (NegType t2)</tt>, then one
--   can use the default implementation via <tt>a-b = a + (-b)</tt>.
class CanSub t1 t2 where type SubType t1 t2 type SubType t1 t2 = AddType t1 (NegType t2) a `sub` b = a + (negate b) where {
    type family SubType t1 t2;
    type SubType t1 t2 = AddType t1 (NegType t2);
}
sub :: CanSub t1 t2 => t1 -> t2 -> SubType t1 t2
sub :: (CanSub t1 t2, SubType t1 t2 ~ AddType t1 (NegType t2), CanNeg t2, CanAdd t1 (NegType t2)) => t1 -> t2 -> SubType t1 t2
type CanSubThis t1 t2 = (CanSub t1 t2, SubType t1 t2 ~ t1)
type CanSubSameType t = CanSubThis t t
(-) :: (CanSub t1 t2) => t1 -> t2 -> SubType t1 t2
infixl 6 -

-- | HSpec properties that each implementation of CanSub should satisfy.
specCanSub :: (CanSubX t1 t1, CanSubX t1 t2, CanNeg t2, CanAdd t1 (NegType t2), HasEqCertainly (SubType t1 t2) (AddType t1 (NegType t2)), Show (AddType t1 (NegType t2)), ConvertibleExactly Integer t1) => T t1 -> T t2 -> Spec

-- | HSpec properties that each implementation of CanSub should satisfy.
specCanSubNotMixed :: (CanSubX t t, CanSubX t (SubType t t), CanNeg t, CanAdd t (NegType t), Show (AddType t (NegType t)), HasEqCertainly (SubType t t) (AddType t (NegType t)), ConvertibleExactly Integer t) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanSubX t1 t2 = (CanSub t1 t2, HasEqCertainly t1 (SubType t1 t2), CanAddXX t1 t2, Show (SubType t1 t2))
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a b => Numeric.MixedTypes.AddSub.CanAddAsymmetric [a] [b]
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a b => Numeric.MixedTypes.AddSub.CanAddAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub a b => Numeric.MixedTypes.AddSub.CanSub [a] [b]
instance Numeric.MixedTypes.AddSub.CanSub a b => Numeric.MixedTypes.AddSub.CanSub (GHC.Base.Maybe a) (GHC.Base.Maybe b)


module Numeric.MixedTypes.Ring
type CanAddSubMulBy t s = (CanAddThis t s, CanSubThis t s, CanMulBy t s)
type Ring t = (CanNegSameType t, CanAddSameType t, CanSubSameType t, CanMulSameType t, CanPowBy t Integer, CanPowBy t Int, HasEq t t, HasEq t Integer, CanAddSubMulBy t Integer, CanSub Integer t, SubType Integer t ~ t, HasEq t Int, CanAddSubMulBy t Int, CanSub Int t, SubType Int t ~ t, ConvertibleExactly Integer t)
type CertainlyEqRing t = (Ring t, HasEqCertainly t t, HasEqCertainly t Int, HasEqCertainly t Integer)
type OrderedRing t = (Ring t, HasOrder t t, HasOrder t Int, HasOrder t Integer)
type OrderedCertainlyRing t = (CertainlyEqRing t, HasOrderCertainly t t, HasOrderCertainly t Int, HasOrderCertainly t Integer, CanTestPosNeg t)
type CanMul t1 t2 = (CanMulAsymmetric t1 t2, CanMulAsymmetric t2 t1, MulType t1 t2 ~ MulType t2 t1)

-- | A replacement for Prelude's <a>*</a>. If <tt>t1 = t2</tt> and <tt>Num
--   t1</tt>, then one can use the default implementation to mirror
--   Prelude's <tt>*</tt>.
class CanMulAsymmetric t1 t2 where type MulType t1 t2 type MulType t1 t2 = t1 mul = (*) where {
    type family MulType t1 t2;
    type MulType t1 t2 = t1;
}
mul :: CanMulAsymmetric t1 t2 => t1 -> t2 -> MulType t1 t2
mul :: (CanMulAsymmetric t1 t2, MulType t1 t2 ~ t1, t1 ~ t2, Num t1) => t1 -> t1 -> t1
type CanMulBy t1 t2 = (CanMul t1 t2, MulType t1 t2 ~ t1)
type CanMulSameType t = CanMulBy t t
(*) :: (CanMulAsymmetric t1 t2) => t1 -> t2 -> MulType t1 t2
infixl 7 *
product :: (CanMulSameType t, ConvertibleExactly Integer t) => [t] -> t

-- | HSpec properties that each implementation of CanMul should satisfy.
specCanMul :: (CanMulX t1 t2, CanMulX t1 t3, CanMulX t2 t3, CanMulX t1 (MulType t2 t3), CanMulX (MulType t1 t2) t3, HasEqCertainly (MulType t1 (MulType t2 t3)) (MulType (MulType t1 t2) t3), CanAdd t2 t3, CanMulX t1 (AddType t2 t3), CanAddX (MulType t1 t2) (MulType t1 t3), HasEqCertainly (MulType t1 (AddType t2 t3)) (AddType (MulType t1 t2) (MulType t1 t3)), ConvertibleExactly Integer t2) => T t1 -> T t2 -> T t3 -> Spec

-- | HSpec properties that each implementation of CanMul should satisfy.
specCanMulNotMixed :: (CanMulX t t, CanMulX t (MulType t t), HasEqCertainly (MulType (MulType t t) t) (MulType t (MulType t t)), CanAdd t t, CanMulX t (AddType t t), CanAddX (MulType t t) (MulType t t), HasEqCertainly (MulType t (AddType t t)) (AddType (MulType t t) (MulType t t)), ConvertibleExactly Integer t) => T t -> Spec

-- | HSpec properties that each implementation of CanMulSameType should
--   satisfy.
specCanMulSameType :: (ConvertibleExactly Integer t, Show t, HasEqCertainly t t, CanMulSameType t) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanMulX t1 t2 = (CanMul t1 t2, Show t1, Arbitrary t1, Show t2, Arbitrary t2, Show (MulType t1 t2), HasEqCertainly t1 (MulType t1 t2), HasEqCertainly t2 (MulType t1 t2), HasEqCertainly (MulType t1 t2) (MulType t1 t2), HasOrderCertainly t1 (MulType t1 t2), HasOrderCertainly t2 (MulType t1 t2), HasOrderCertainly (MulType t1 t2) (MulType t1 t2))

-- | A replacement for Prelude's binary <a>^</a> and <a>^^</a>. If <tt>Num
--   t1</tt> and <tt>Integral t2</tt>, then one can use the default
--   implementation to mirror Prelude's <tt>^</tt>.
class CanPow t1 t2 where type PowType t1 t2 type PowType t1 t2 = t1 pow = (^) where {
    type family PowType t1 t2;
    type PowType t1 t2 = t1;
}
pow :: CanPow t1 t2 => t1 -> t2 -> PowType t1 t2
pow :: (CanPow t1 t2, PowType t1 t2 ~ t1, Num t1, Integral t2) => t1 -> t2 -> t1
type CanPowBy t1 t2 = (CanPow t1 t2, PowType t1 t2 ~ t1)
(^) :: (CanPow t1 t2) => t1 -> t2 -> PowType t1 t2
infixl 8 ^

-- | A synonym of <a>^</a>
(^^) :: (CanPow t1 t2) => t1 -> t2 -> PowType t1 t2
infixl 8 ^^

-- | A synonym of <a>^</a>
(**) :: (CanPow t1 t2) => t1 -> t2 -> (PowType t1 t2)
powUsingMul :: (CanBeInteger e, CanMulSameType t, ConvertibleExactly Integer t) => t -> e -> t

-- | HSpec properties that each implementation of CanPow should satisfy.
specCanPow :: (CanPowX t1 t2, HasEqCertainly t1 (PowType t1 t2), ConvertibleExactly Integer t1, ConvertibleExactly Integer t2, CanTestPosNeg t2, CanAdd t2 Integer, CanMulX t1 (PowType t1 t2), CanPowX t1 (AddType t2 Integer), HasEqCertainly (MulType t1 (PowType t1 t2)) (PowType t1 (AddType t2 Integer))) => T t1 -> T t2 -> Spec

-- | Compound type constraint useful for test definition.
type CanPowX t1 t2 = (CanPow t1 t2, Show t1, Arbitrary t1, Show t2, Arbitrary t2, Show (PowType t1 t2))
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a b => Numeric.MixedTypes.Ring.CanMulAsymmetric [a] [b]
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a b => Numeric.MixedTypes.Ring.CanMulAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow a b => Numeric.MixedTypes.Ring.CanPow (GHC.Base.Maybe a) (GHC.Base.Maybe b)


module Numeric.MixedTypes.Field
type CanAddSubMulDivBy t s = (CanAddSubMulBy t s, CanDivBy t s)
type Field t = (Ring t, CanDivSameType t, CanRecipSameType t, CanAddSubMulDivBy t Rational, CanAddSubMulDivBy t Integer, CanAddSubMulDivBy t Int)
type CertainlyEqField t = (Field t, CertainlyEqRing t)
type OrderedField t = (Field t, OrderedRing t, HasOrder t Rational)
type OrderedCertainlyField t = (CertainlyEqField t, OrderedCertainlyRing t, HasOrderCertainly t Rational)

-- | A replacement for Prelude's binary <a>/</a>. If <tt>t1 = t2</tt> and
--   <tt>Fractional t1</tt>, then one can use the default implementation to
--   mirror Prelude's <tt>/</tt>.
class CanDiv t1 t2 where type DivType t1 t2 type DivType t1 t2 = t1 divide = (/) where {
    type family DivType t1 t2;
    type DivType t1 t2 = t1;
}
divide :: CanDiv t1 t2 => t1 -> t2 -> DivType t1 t2
divide :: (CanDiv t1 t2, DivType t1 t2 ~ t1, t1 ~ t2, Fractional t1) => t1 -> t1 -> t1
type CanDivBy t1 t2 = (CanDiv t1 t2, DivType t1 t2 ~ t1)
type CanDivSameType t = CanDivBy t t
type CanRecip t = CanDiv Integer t
type CanRecipSameType t = (CanDiv Integer t, DivType Integer t ~ t)
(/) :: (CanDiv t1 t2) => t1 -> t2 -> DivType t1 t2
recip :: (CanRecip t) => t -> DivType Integer t
powUsingMulRecip :: (CanBeInteger e, CanRecipSameType t, CanMulSameType t, ConvertibleExactly Integer t) => t -> e -> t

-- | HSpec properties that each implementation of CanDiv should satisfy.
specCanDiv :: (CanRecip t1, CanRecip (DivType Integer t1), Show (DivType Integer (DivType Integer t1)), HasEqCertainly t1 (DivType Integer (DivType Integer t1)), CanTestZero (DivType Integer t1), CanDivX t1 t2, CanTestZero t1, CanTestZero t2, CanDivX t1 t1, CanMulX t1 (DivType t1 t2), ConvertibleExactly Integer t2, ConvertibleExactly Integer t1) => T t1 -> T t2 -> Spec

-- | HSpec properties that each implementation of CanDiv should satisfy.
specCanDivNotMixed :: (CanRecip t, CanRecip (DivType Integer t), Show (DivType Integer (DivType Integer t)), HasEqCertainly t (DivType Integer (DivType Integer t)), CanTestZero (DivType Integer t), CanDivX t t, CanTestZero t, CanMulX t (DivType t t), ConvertibleExactly Integer t) => T t -> Spec

-- | Compound type constraint useful for test definition.
type CanDivX t1 t2 = (CanDiv t1 t2, Show t1, Arbitrary t1, Show t2, Arbitrary t2, Show (DivType t1 t2), HasEqCertainly t1 (DivType t1 t2))
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv a b => Numeric.MixedTypes.Field.CanDiv [a] [b]
instance Numeric.MixedTypes.Field.CanDiv a b => Numeric.MixedTypes.Field.CanDiv (GHC.Base.Maybe a) (GHC.Base.Maybe b)


module Numeric.MixedTypes.Elementary

-- | A replacement for Prelude's <a>sqrt</a>. If <tt>Floating t</tt>, then
--   one can use the default implementation to mirror Prelude's
--   <tt>sqrt</tt>.
class CanSqrt t where type SqrtType t type SqrtType t = t sqrt = sqrt where {
    type family SqrtType t;
    type SqrtType t = t;
}
sqrt :: CanSqrt t => t -> SqrtType t
sqrt :: (CanSqrt t, SqrtType t ~ t, Floating t) => t -> t
type CanSqrtSameType t = (CanSqrt t, SqrtType t ~ t)

-- | HSpec properties that each implementation of CanSqrt should satisfy.
specCanSqrtReal :: (CanSqrtX t, CanPowX (SqrtType t) Integer, HasEqCertainly t (PowType (SqrtType t) Integer)) => T t -> Spec

-- | A replacement for Prelude's <a>exp</a>. If <tt>Floating t</tt>, then
--   one can use the default implementation to mirror Prelude's
--   <tt>exp</tt>.
class CanExp t where type ExpType t type ExpType t = t exp = exp where {
    type family ExpType t;
    type ExpType t = t;
}
exp :: CanExp t => t -> ExpType t
exp :: (CanExp t, ExpType t ~ t, Floating t) => t -> t
type CanExpSameType t = (CanExp t, ExpType t ~ t)

-- | HSpec properties that each implementation of CanExp should satisfy.
specCanExpReal :: (CanExpX t) => T t -> Spec

-- | A replacement for Prelude's <a>log</a>. If <tt>Floating t</tt>, then
--   one can use the default implementation to mirror Prelude's
--   <tt>log</tt>.
class CanLog t where type LogType t type LogType t = t log = log where {
    type family LogType t;
    type LogType t = t;
}
log :: CanLog t => t -> LogType t
log :: (CanLog t, LogType t ~ t, Floating t) => t -> t
type CanLogSameType t = (CanLog t, LogType t ~ t)

-- | HSpec properties that each implementation of CanLog should satisfy.
specCanLogReal :: (CanLogX t, CanLogX (DivType Integer t), CanExp t, CanLogX (ExpType t), HasEqCertainly t (LogType (ExpType t))) => T t -> Spec
powUsingExpLog :: (CanTestPosNeg t1, CanMulSameType t1, HasIntegers t1, CanTestZero t1, CanRecipSameType t1, CanTestInteger t2, CanTestPosNeg t2, CanMulAsymmetric (LogType t1) t2, CanLog t1, CanExp (MulType (LogType t1) t2), ExpType (MulType (LogType t1) t2) ~ t1) => t1 -> t2 -> ExpType (MulType (LogType t1) t2)

-- | A replacement for Prelude's <a>cos</a> and <a>sin</a>. If <tt>Floating
--   t</tt>, then one can use the default implementation to mirror
--   Prelude's <tt>sin</tt>, <tt>cos</tt>.
class CanSinCos t where type SinCosType t type SinCosType t = t cos = cos sin = sin where {
    type family SinCosType t;
    type SinCosType t = t;
}
cos :: CanSinCos t => t -> SinCosType t
cos :: (CanSinCos t, SinCosType t ~ t, Floating t) => t -> t
sin :: CanSinCos t => t -> SinCosType t
sin :: (CanSinCos t, SinCosType t ~ t, Floating t) => t -> t
type CanSinCosSameType t = (CanSinCos t, SinCosType t ~ t)

-- | HSpec properties that each implementation of CanSinCos should satisfy.
--   
--   Derived partially from
--   <a>http://math.stackexchange.com/questions/1303044/axiomatic-definition-of-sin-and-cos</a>
specCanSinCosReal :: (CanSinCosX t) => T t -> Spec

-- | Approximate pi, synonym for Prelude's <a>pi</a>.
--   
--   We do not define (exect) <tt>pi</tt> in this package as we have no
--   type that can represent it exactly.
approxPi :: (Floating t) => t
instance Numeric.MixedTypes.Elementary.CanSqrt GHC.Types.Double
instance Numeric.MixedTypes.Elementary.CanExp GHC.Types.Double
instance Numeric.MixedTypes.Elementary.CanLog GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Double GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Double GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int GHC.Types.Double
instance Numeric.MixedTypes.Elementary.CanSinCos GHC.Types.Double


module Numeric.MixedTypes.Round

-- | A replacement for Prelude's <a>RealFrac</a> operations, such as round
--   in which the result type is fixed to Integer.
--   
--   If <tt>RealFrac t</tt> and <tt>CanTestPosNeg t</tt>, then one can use
--   the default implementation to mirror Prelude's <tt>round</tt>, etc.
--   
--   In other cases, it is sufficient to define <a>properFraction</a>.
class CanRound t where properFraction = properFraction truncate = fst . properFraction round x | - 0.5 !<! r && r !<! 0.5 = n | r !<! - 0.5 = n - 1 | r !>! 0.5 = n + 1 | even n = n | r !<! 0.0 = n - 1 | r !>! 0.0 = n + 1 | otherwise = error "round default defn: Bad value" where (n, r) = properFraction x ceiling x | isCertainlyPositive r = n + 1 | otherwise = n where (n, r) = properFraction x floor x | isCertainlyNegative r = n - 1 | otherwise = n where (n, r) = properFraction x
properFraction :: CanRound t => t -> (Integer, t)
properFraction :: (CanRound t, RealFrac t) => t -> (Integer, t)
truncate :: CanRound t => t -> Integer
round :: CanRound t => t -> Integer
round :: (CanRound t, HasOrderCertainly t Rational) => t -> Integer
ceiling :: CanRound t => t -> Integer
ceiling :: (CanRound t, CanTestPosNeg t) => t -> Integer
floor :: CanRound t => t -> Integer
floor :: (CanRound t, CanTestPosNeg t) => t -> Integer
class HasIntegerBounds t where integerBounds x = (floor x, ceiling x)
integerBounds :: HasIntegerBounds t => t -> (Integer, Integer)
integerBounds :: (HasIntegerBounds t, CanRound t) => t -> (Integer, Integer)

-- | HSpec properties that each implementation of CanRound should satisfy.
specCanRound :: (CanRoundX t, HasIntegers t) => T t -> Spec

-- | HSpec properties that each implementation of CanRound should satisfy.
specHasIntegerBounds :: (HasIntegerBoundsX t) => T t -> Spec
instance Numeric.MixedTypes.Round.CanRound GHC.Real.Rational
instance Numeric.MixedTypes.Round.CanRound GHC.Types.Double
instance Numeric.MixedTypes.Round.HasIntegerBounds GHC.Real.Rational
instance Numeric.MixedTypes.Round.HasIntegerBounds GHC.Types.Double


-- | <h1>Main purpose</h1>
--   
--   This package provides a version of Prelude where unary and binary
--   operations such as <tt>not</tt>, <tt>+</tt>, <tt>==</tt> have their
--   result type derived from the parameter type(s), allowing, <i>e.g.</i>:
--   
--   <ul>
--   <li>dividing an integer by an integer, giving a rational:</li>
--   </ul>
--   
--   <pre>
--   let n = 1 :: Integer in n/(n+1) :: Rational
--   </pre>
--   
--   <pre>
--   1/2 :: Rational
--   </pre>
--   
--   (The type Rational would be derived automatically because integer
--   literals are always of type <tt>Integer</tt>, not <tt>Num t =&gt;
--   t</tt>.)
--   
--   <ul>
--   <li>adding an integer and a rational, giving a rational:</li>
--   </ul>
--   
--   <pre>
--   (length [x])+1/3 :: Rational
--   </pre>
--   
--   <ul>
--   <li>taking natural, integer and fractional power using the same
--   operator:</li>
--   </ul>
--   
--   <pre>
--   2^2 :: Integer
--   </pre>
--   
--   <pre>
--   2.0^(-2) :: Rational
--   </pre>
--   
--   <pre>
--   (double 2)^(1/2) :: Double
--   </pre>
--   
--   The following examples require package <a>aern2-real</a>:
--   
--   <pre>
--   2^(1/2) :: CauchyReal
--   </pre>
--   
--   <pre>
--   pi :: CauchyReal
--   </pre>
--   
--   <pre>
--   sqrt 2 :: CauchyReal
--   </pre>
--   
--   <ul>
--   <li>comparing an integer with an (exact) real number, giving a
--   <tt>Maybe Bool</tt>:</li>
--   </ul>
--   
--   <pre>
--   ... x :: CauchyReal ... if (isCertainlyTrue (x &gt; 1)) then ...
--   </pre>
--   
--   <h1>Type classes</h1>
--   
--   Arithmetic operations are provided via multi-parameter type classes
--   and the result type is given by associated type families. For example:
--   
--   <pre>
--   (+) :: (CanAddAsymmetric t1 t2) =&gt; t1 -&gt; t2 -&gt; AddType t1 t2
--   </pre>
--   
--   The type constraint <tt>CanAdd t1 t2</tt> implies both
--   <tt>CanAddAsymmetric t1 t2</tt> and <tt>CanAddAsymmetric t2 t1</tt>.
--   
--   For convenience there are other aggregate type constraints such as
--   <tt>CanAddThis t1 t2</tt>, which implies that the result is of type
--   <tt>t1</tt>, and <tt>CanAddSameType t</tt>, which is a shortcut for
--   <tt>CanAddThis t t</tt>.
--   
--   <h2>Testable specification</h2>
--   
--   The arithmetic type classes are accompanied by generic hspec test
--   suites, which are specialised to concrete instance types for their
--   testing. These test suites include the expected algebraic properties
--   of operations, such as commutativity and associativity of addition.
--   
--   <h1>Limitations</h1>
--   
--   <ul>
--   <li>Not all numerical operations are supported yet. Eg <tt>tan</tt>,
--   <tt>atan</tt> are missing at the moment.</li>
--   </ul>
--   
--   <ul>
--   <li>Inferred types can be very large. Eg for <tt>f a b c = sqrt (a + b
--   * c + 1)</tt> the inferred type is:</li>
--   </ul>
--   
--   <pre>
--   f: (CanMulAsymmetric t1 t2, CanAddAsymmetric t4 (MulType t1 t2),
--       CanAddAsymmetric (AddType t4 (MulType t1 t2)) Integer,
--       CanSqrt (AddType (AddType t4 (MulType t1 t2)) Integer)) =&gt;
--      t4
--      -&gt; t1
--      -&gt; t2
--      -&gt; SqrtType (AddType (AddType t4 (MulType t1 t2)) Integer)
--   
--   </pre>
--   
--   <ul>
--   <li>Due to limitations of some versions of ghc, type inferrence
--   sometimes fails. Eg <tt>add1 = (+ 1)</tt> fails (eg with ghc 8.0.2)
--   unless we explicitly declare the type <tt>add1 :: (CanAdd Integer t)
--   =&gt; t -&gt; AddType t Integer</tt> or use an explicit parameter, eg
--   <tt>add1 x = x + 1</tt>.</li>
--   </ul>
--   
--   <h1>Origin</h1>
--   
--   The idea of having numeric expressions in Haskell with types derived
--   bottom-up was initially suggested and implemented by Pieter Collins.
--   This version is a fresh rewrite by Michal Konen.
--   
--   <h1>More details</h1>
--   
--   This module facilitates a single-line import for the package
--   mixed-types-num. See the re-exported modules for further details.
module Numeric.MixedTypes

module Control.EnsureTypeOp

-- | A mechanism for applying a type operator to a type except when the
--   type already has that operator.
type EnsureTypeOp f a = f (RemoveTypeOp f a)

-- | A mechanism for translating a value of a type <tt>a</tt> to a value of
--   a type <tt>f a</tt> except when <tt>a = f b</tt> for some <tt>b</tt>,
--   in which case the value is left as is.
class CanEnsureTypeOp f a
ensureTypeOp :: CanEnsureTypeOp f a => a -> EnsureTypeOp f a
instance Control.EnsureTypeOp.CanEnsureTypeOp f (f a)

module Control.CollectErrors

-- | A wrapper around values which can accommodate a list of (potential)
--   errors that have (maybe) occurred during the computation of a value. A
--   value may be missing, leaving only the error(s).
--   
--   Such error collectoin allows one to write expressions with partial
--   functions (ie functions that fail for some inputs) instead of
--   branching after each application of such function. Dealing with the
--   errors can be moved outside the expression. If the error data contain
--   enough information, their list can be used to trace the source of the
--   errors.
data CollectErrors es v
CollectErrors :: (Maybe v) -> es -> CollectErrors es v

-- | Wrap a pure value in a CollectErrors record
noErrors :: (Monoid es) => v -> CollectErrors es v

-- | Make CollectErrors record with no value, only errors.
noValue :: es -> CollectErrors es v

-- | Add further errors into a CollectErrors record.
prependErrors :: (Monoid es) => es -> CollectErrors es v -> CollectErrors es v

-- | Add error collection support to a binary function.
lift2 :: (Monoid es) => (a -> b -> c) -> (CollectErrors es a) -> (CollectErrors es b) -> (CollectErrors es c)

-- | An utility function for easily defining a binary function with only
--   the second parameter collecting errors, if we have an analogous
--   function that requires both parameters to collect errors.
unlift2first :: (Monoid es) => ((CollectErrors es a) -> (CollectErrors es b) -> t) -> (a -> (CollectErrors es b) -> t)

-- | An utility function for easily defining a binary function with only
--   the first parameter collecting errors, if we have an analogous
--   function that requires both parameters to collect errors.
unlift2second :: (Monoid es) => ((CollectErrors es a) -> (CollectErrors es b) -> t) -> ((CollectErrors es a) -> b -> t)

-- | Translate a value of a type <tt>a</tt> to a value of a type
--   <tt>CollectErrors es a</tt> except when <tt>a</tt> already is a
--   <tt>CollectErrors</tt> type, in which case the value is left as is.
ensureCollectErrors :: (CanEnsureCollectErrors es v) => v -> EnsureCollectErrors es v
type CanEnsureCollectErrors es v = CanEnsureTypeOp (CollectErrors es) v

-- | Apply CollectErrors to a type except when the type already is a
--   CollectErrors type.
type EnsureCollectErrors es v = EnsureTypeOp (CollectErrors es) v

-- | Add error collection support to a binary function whose result may
--   already have collected errors.
lift2ensureCE :: (Monoid es, CanEnsureCollectErrors es c) => (a -> b -> c) -> (CollectErrors es a) -> (CollectErrors es b) -> (EnsureCollectErrors es c)
instance (GHC.Show.Show es, GHC.Show.Show v) => GHC.Show.Show (Control.CollectErrors.CollectErrors es v)
instance GHC.Base.Functor (Control.CollectErrors.CollectErrors es)
instance GHC.Base.Monoid es => GHC.Base.Applicative (Control.CollectErrors.CollectErrors es)
instance GHC.Base.Monoid es => GHC.Base.Monad (Control.CollectErrors.CollectErrors es)
instance GHC.Base.Monoid es => Control.EnsureTypeOp.CanEnsureTypeOp (Control.CollectErrors.CollectErrors es) GHC.Types.Int
instance GHC.Base.Monoid es => Control.EnsureTypeOp.CanEnsureTypeOp (Control.CollectErrors.CollectErrors es) GHC.Integer.Type.Integer
instance GHC.Base.Monoid es => Control.EnsureTypeOp.CanEnsureTypeOp (Control.CollectErrors.CollectErrors es) GHC.Real.Rational
instance GHC.Base.Monoid es => Control.EnsureTypeOp.CanEnsureTypeOp (Control.CollectErrors.CollectErrors es) GHC.Types.Char
instance GHC.Base.Monoid es => Control.EnsureTypeOp.CanEnsureTypeOp (Control.CollectErrors.CollectErrors es) GHC.Types.Bool
instance GHC.Base.Monoid es => Control.EnsureTypeOp.CanEnsureTypeOp (Control.CollectErrors.CollectErrors es) [a]
instance GHC.Base.Monoid es => Control.EnsureTypeOp.CanEnsureTypeOp (Control.CollectErrors.CollectErrors es) (GHC.Base.Maybe a)
instance GHC.Base.Monoid es => Control.EnsureTypeOp.CanEnsureTypeOp (Control.CollectErrors.CollectErrors es) (Data.Either.Either e a)

module Numeric.MixedTypes.Concept.CollectErrors
type NumErrors = [(ErrorCertaintyLevel, NumError)]
data ErrorCertaintyLevel
ErrorCertain :: ErrorCertaintyLevel
ErrorPotential :: ErrorCertaintyLevel
data NumError
DivByZero :: NumError
OutOfRange :: String -> NumError
NumError :: String -> NumError
type CollectNumErrors v = CollectErrors NumErrors v
type CanEnsureCollectNumErrors v = CanEnsureCollectErrors NumErrors v
noNumErrors :: v -> CollectNumErrors v
class CanMyDiv a b where type MyDivType a b where {
    type family MyDivType a b;
}
myDiv :: CanMyDiv a b => a -> b -> MyDivType a b
(/!) :: (CanMyDiv a b) => a -> b -> MyDivType a b
withErrorsExample1 :: CollectNumErrors Rational
withErrorsExample2 :: CollectNumErrors Rational
withErrorsExample3 :: CollectNumErrors Rational
class CanMyMul a b where type MyMulType a b where {
    type family MyMulType a b;
}
myMul :: CanMyMul a b => a -> b -> MyMulType a b
(*!) :: (CanMyMul a b) => a -> b -> MyMulType a b
withErrorsExample4 :: CollectNumErrors Rational
instance GHC.Show.Show Numeric.MixedTypes.Concept.CollectErrors.NumError
instance GHC.Show.Show Numeric.MixedTypes.Concept.CollectErrors.ErrorCertaintyLevel
instance Numeric.MixedTypes.Concept.CollectErrors.CanMyDiv GHC.Real.Rational GHC.Real.Rational
instance (Numeric.MixedTypes.Concept.CollectErrors.CanMyDiv a b, GHC.Base.Monoid es, Control.CollectErrors.CanEnsureCollectErrors es (Numeric.MixedTypes.Concept.CollectErrors.MyDivType a b)) => Numeric.MixedTypes.Concept.CollectErrors.CanMyDiv (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Concept.CollectErrors.CanMyDiv GHC.Real.Rational b, GHC.Base.Monoid es, Control.CollectErrors.CanEnsureCollectErrors es (Numeric.MixedTypes.Concept.CollectErrors.MyDivType GHC.Real.Rational b)) => Numeric.MixedTypes.Concept.CollectErrors.CanMyDiv GHC.Real.Rational (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Concept.CollectErrors.CanMyDiv a GHC.Real.Rational, GHC.Base.Monoid es, Control.CollectErrors.CanEnsureCollectErrors es (Numeric.MixedTypes.Concept.CollectErrors.MyDivType a GHC.Real.Rational)) => Numeric.MixedTypes.Concept.CollectErrors.CanMyDiv (Control.CollectErrors.CollectErrors es a) GHC.Real.Rational
instance Numeric.MixedTypes.Concept.CollectErrors.CanMyMul GHC.Real.Rational GHC.Real.Rational
instance (Numeric.MixedTypes.Concept.CollectErrors.CanMyMul a b, GHC.Base.Monoid es, Control.CollectErrors.CanEnsureCollectErrors es (Numeric.MixedTypes.Concept.CollectErrors.MyMulType a b)) => Numeric.MixedTypes.Concept.CollectErrors.CanMyMul (Control.CollectErrors.CollectErrors es a) (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Concept.CollectErrors.CanMyMul GHC.Real.Rational b, GHC.Base.Monoid es, Control.CollectErrors.CanEnsureCollectErrors es (Numeric.MixedTypes.Concept.CollectErrors.MyMulType GHC.Real.Rational b)) => Numeric.MixedTypes.Concept.CollectErrors.CanMyMul GHC.Real.Rational (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Concept.CollectErrors.CanMyMul a GHC.Real.Rational, GHC.Base.Monoid es, Control.CollectErrors.CanEnsureCollectErrors es (Numeric.MixedTypes.Concept.CollectErrors.MyMulType a GHC.Real.Rational)) => Numeric.MixedTypes.Concept.CollectErrors.CanMyMul (Control.CollectErrors.CollectErrors es a) GHC.Real.Rational
